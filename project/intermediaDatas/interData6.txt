Алфавит и сгенерированные специальные кода каждого символа:
a - 0000000

b - 0000001

c - 0000010

d - 0000011

e - 0000100

f - 0000101

g - 0000110

h - 0000111

i - 0001000

j - 0001001

k - 0001010

l - 0001011

m - 000110

n - 000111

o - 001000

p - 001001

q - 001010

r - 001011

s - 001100

t - 001101

u - 001110

v - 001111

w - 010000

x - 010001

y - 010010

z - 010011

A - 010100

B - 010101

C - 010110

D - 010111

E - 011000

F - 011001

G - 011010

H - 011011

I - 011100

J - 011101

K - 011110

L - 011111

M - 100000

N - 100001

O - 100010

P - 100011

Q - 100100

R - 100101

S - 100110

T - 100111

U - 101000

V - 101001

W - 101010

X - 101011

Y - 101100

Z - 101101

0 - 101110

1 - 101111

2 - 110000

3 - 110001

4 - 110010

5 - 110011

6 - 110100

7 - 110101

8 - 110110

9 - 110111

. - 111000

, - 111001

! - 111010

? - 111011

: - 111100

( - 111101

) - 111110

  - 111111


Промежуточные данные:
---------------------------------
На вход кодировщику поступает символ 'a'
Текущее дерево кодировщика:
(0[\0])

Символ 'a' еще не встречался в кодируемом сообщении =>
1) Берется код пустого символа: 
2) К нему добавляется спец-код символа 'a' из алфавита: 0000000
3) К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'a':
       (0)      
(0[\0])   (1[a])

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
       (1)      
(0[\0])   (1[a])

Результат кодирования символа 'a' - 0000000
---------------------------------
---------------------------------
На вход кодировщику поступает символ 'b'
Текущее дерево кодировщика:
       (1)      
(0[\0])   (1[a])

Символ 'b' еще не встречался в кодируемом сообщении =>
1) Берется код пустого символа: 0
2) К нему добавляется спец-код символа 'b' из алфавита: 0000001
3) К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'b':
                (1)      
       (0)         (1[a])
(0[\0])   (1[b])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                (2)      
       (1)         (1[a])
(0[\0])   (1[b])         

Результат кодирования символа 'b' - 00000001
---------------------------------
---------------------------------
На вход кодировщику поступает символ 'c'
Текущее дерево кодировщика:
                (2)      
       (1)         (1[a])
(0[\0])   (1[b])         

Символ 'c' еще не встречался в кодируемом сообщении =>
1) Берется код пустого символа: 00
2) К нему добавляется спец-код символа 'c' из алфавита: 0000010
3) К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'c':
                         (2)      
                (1)         (1[a])
       (0)         (1[b])         
(0[\0])   (1[c])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                         (3)      
                (2)         (1[a])
       (1)         (1[b])         
(0[\0])   (1[c])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[b])
(0[\0])   (1[c])         

и

(1[a])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (3)                         
(1[a])                   (2)      
                (1)         (1[b])
         (0[\0])   (1[c])         

Результат кодирования символа 'c' - 000000010
---------------------------------
---------------------------------
На вход кодировщику поступает символ 'd'
Текущее дерево кодировщика:
      (3)                         
(1[a])                   (2)      
                (1)         (1[b])
         (0[\0])   (1[c])         

Символ 'd' еще не встречался в кодируемом сообщении =>
1) Берется код пустого символа: 100
2) К нему добавляется спец-код символа 'd' из алфавита: 0000011
3) К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'd':
      (3)                                  
(1[a])                            (2)      
                         (1)         (1[b])
                (0)         (1[c])         
         (0[\0])   (1[d])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
      (4)                                  
(1[a])                            (3)      
                         (2)         (1[b])
                (1)         (1[c])         
         (0[\0])   (1[d])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[c])
(0[\0])   (1[d])         

и

(1[a])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                         (4)               
                (2)               (2)      
       (1)         (1[c])   (1[a])   (1[b])
(0[\0])   (1[d])                           

Результат кодирования символа 'd' - 1000000011
---------------------------------
---------------------------------
На вход кодировщику поступает символ 'e'
Текущее дерево кодировщика:
                         (4)               
                (2)               (2)      
       (1)         (1[c])   (1[a])   (1[b])
(0[\0])   (1[d])                           

Символ 'e' еще не встречался в кодируемом сообщении =>
1) Берется код пустого символа: 000
2) К нему добавляется спец-код символа 'e' из алфавита: 0000100
3) К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'e':
                                  (4)               
                         (2)               (2)      
                (1)         (1[c])   (1[a])   (1[b])
       (0)         (1[d])                           
(0[\0])   (1[e])                                    

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                  (5)               
                         (3)               (2)      
                (2)         (1[c])   (1[a])   (1[b])
       (1)         (1[d])                           
(0[\0])   (1[e])                                    

Требуется перевесить ветки:
                (2)      
       (1)         (1[d])
(0[\0])   (1[e])         

и

(1[b])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
               (5)                                  
      (2)               (3)                         
(1[b])   (1[c])   (1[a])                   (2)      
                                  (1)         (1[d])
                           (0[\0])   (1[e])         

Результат кодирования символа 'e' - 0000000100
---------------------------------
---------------------------------
На вход кодировщику поступает символ 'f'
Текущее дерево кодировщика:
               (5)                                  
      (2)               (3)                         
(1[b])   (1[c])   (1[a])                   (2)      
                                  (1)         (1[d])
                           (0[\0])   (1[e])         

Символ 'f' еще не встречался в кодируемом сообщении =>
1) Берется код пустого символа: 1100
2) К нему добавляется спец-код символа 'f' из алфавита: 0000101
3) К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'f':
               (5)                                           
      (2)               (3)                                  
(1[b])   (1[c])   (1[a])                            (2)      
                                           (1)         (1[d])
                                  (0)         (1[e])         
                           (0[\0])   (1[f])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
               (6)                                           
      (2)               (4)                                  
(1[b])   (1[c])   (1[a])                            (3)      
                                           (2)         (1[d])
                                  (1)         (1[e])         
                           (0[\0])   (1[f])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[e])
(0[\0])   (1[f])         

и

(1[a])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
               (6)                                           
      (2)                                  (4)               
(1[b])   (1[c])                   (2)               (2)      
                         (1)         (1[e])   (1[a])   (1[d])
                  (0[\0])   (1[f])                           

Результат кодирования символа 'f' - 11000000101
---------------------------------
---------------------------------
На вход кодировщику поступает символ 'g'
Текущее дерево кодировщика:
               (6)                                           
      (2)                                  (4)               
(1[b])   (1[c])                   (2)               (2)      
                         (1)         (1[e])   (1[a])   (1[d])
                  (0[\0])   (1[f])                           

Символ 'g' еще не встречался в кодируемом сообщении =>
1) Берется код пустого символа: 1000
2) К нему добавляется спец-код символа 'g' из алфавита: 0000110
3) К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'g':
               (6)                                                    
      (2)                                           (4)               
(1[b])   (1[c])                            (2)               (2)      
                                  (1)         (1[e])   (1[a])   (1[d])
                         (0)         (1[f])                           
                  (0[\0])   (1[g])                                    

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
               (7)                                                    
      (2)                                           (5)               
(1[b])   (1[c])                            (3)               (2)      
                                  (2)         (1[e])   (1[a])   (1[d])
                         (1)         (1[f])                           
                  (0[\0])   (1[g])                                    

Требуется перевесить ветки:
                (2)      
       (1)         (1[f])
(0[\0])   (1[g])         

и

(1[c])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                  (7)                                 
      (3)                                           (4)               
(1[b])                   (2)               (2)               (2)      
                (1)         (1[f])   (1[c])   (1[e])   (1[a])   (1[d])
         (0[\0])   (1[g])                                             

Результат кодирования символа 'g' - 10000000110
---------------------------------
---------------------------------
На вход кодировщику поступает символ 'h'
Текущее дерево кодировщика:
                                  (7)                                 
      (3)                                           (4)               
(1[b])                   (2)               (2)               (2)      
                (1)         (1[f])   (1[c])   (1[e])   (1[a])   (1[d])
         (0[\0])   (1[g])                                             

Символ 'h' еще не встречался в кодируемом сообщении =>
1) Берется код пустого символа: 0100
2) К нему добавляется спец-код символа 'h' из алфавита: 0000111
3) К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'h':
                                           (7)                                 
      (3)                                                    (4)               
(1[b])                            (2)               (2)               (2)      
                         (1)         (1[f])   (1[c])   (1[e])   (1[a])   (1[d])
                (0)         (1[g])                                             
         (0[\0])   (1[h])                                                      

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                           (8)                                 
      (4)                                                    (4)               
(1[b])                            (3)               (2)               (2)      
                         (2)         (1[f])   (1[c])   (1[e])   (1[a])   (1[d])
                (1)         (1[g])                                             
         (0[\0])   (1[h])                                                      

Требуется перевесить ветки:
                (2)      
       (1)         (1[g])
(0[\0])   (1[h])         

и

(1[b])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                           (8)                                 
                         (4)                                 (4)               
                (2)               (2)               (2)               (2)      
       (1)         (1[g])   (1[b])   (1[f])   (1[c])   (1[e])   (1[a])   (1[d])
(0[\0])   (1[h])                                                               

Результат кодирования символа 'h' - 01000000111
---------------------------------
