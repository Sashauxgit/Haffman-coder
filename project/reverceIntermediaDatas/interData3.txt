Алфавит и сгенерированные специальные кода каждого символа:
a - 0000000
b - 0000001
c - 0000010
d - 0000011
e - 0000100
f - 0000101
g - 0000110
h - 0000111
i - 0001000
j - 0001001
k - 0001010
l - 0001011
m - 000110
n - 000111
o - 001000
p - 001001
q - 001010
r - 001011
s - 001100
t - 001101
u - 001110
v - 001111
w - 010000
x - 010001
y - 010010
z - 010011
A - 010100
B - 010101
C - 010110
D - 010111
E - 011000
F - 011001
G - 011010
H - 011011
I - 011100
J - 011101
K - 011110
L - 011111
M - 100000
N - 100001
O - 100010
P - 100011
Q - 100100
R - 100101
S - 100110
T - 100111
U - 101000
V - 101001
W - 101010
X - 101011
Y - 101100
Z - 101101
0 - 101110
1 - 101111
2 - 110000
3 - 110001
4 - 110010
5 - 110011
6 - 110100
7 - 110101
8 - 110110
9 - 110111
. - 111000
, - 111001
! - 111010
? - 111011
: - 111100
( - 111101
) - 111110
  - 111111


Промежуточные данные:
Начало работы декодировщика: на вход декодеру подается последовательность бит:
00101100010000000010101110101001111111000000000111100000000001011010111
---------------------------------
Текущее дерево кодировщика:
(0[\0])

Оставшееся нераскодированное сообщение: 00101100010000000010101110101001111111000000000111100000000001011010111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит:  привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 00101100010000000010101110101001111111000000000111100000000001011010111
Следующий набор бит: 001011 привел декодера к узлу с символом 'r' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'r':
       (0)      
(0[\0])   (1[r])

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
       (1)      
(0[\0])   (1[r])

Текущий результат декодирования сообщения: 'r'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
       (1)      
(0[\0])   (1[r])

Оставшееся нераскодированное сообщение: 00010000000010101110101001111111000000000111100000000001011010111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 0 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0010000000010101110101001111111000000000111100000000001011010111
Следующий набор бит: 001000 привел декодера к узлу с символом 'o' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'o':
                (1)      
       (0)         (1[r])
(0[\0])   (1[o])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                (2)      
       (1)         (1[r])
(0[\0])   (1[o])         

Текущий результат декодирования сообщения: 'ro'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                (2)      
       (1)         (1[r])
(0[\0])   (1[o])         

Оставшееся нераскодированное сообщение: 0000010101110101001111111000000000111100000000001011010111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 00 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 00010101110101001111111000000000111100000000001011010111
Следующий набор бит: 0001010 привел декодера к узлу с символом 'k' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'k':
                         (2)      
                (1)         (1[r])
       (0)         (1[o])         
(0[\0])   (1[k])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                         (3)      
                (2)         (1[r])
       (1)         (1[o])         
(0[\0])   (1[k])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[o])
(0[\0])   (1[k])         

и

(1[r])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (3)                         
(1[r])                   (2)      
                (1)         (1[o])
         (0[\0])   (1[k])         

Текущий результат декодирования сообщения: 'rok'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
      (3)                         
(1[r])                   (2)      
                (1)         (1[o])
         (0[\0])   (1[k])         

Оставшееся нераскодированное сообщение: 1110101001111111000000000111100000000001011010111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 11 привел декодера к узлу с символом 'o', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
      (3)                         
(1[r])                   (2)      
                (1)         (2[o])
         (0[\0])   (1[k])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
      (4)                         
(1[r])                   (3)      
                (1)         (2[o])
         (0[\0])   (1[k])         

Требуется перевесить ветки:
(2[o])

и

(1[r])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (4)                         
(2[o])                   (2)      
                (1)         (1[r])
         (0[\0])   (1[k])         

Текущий результат декодирования сообщения: 'roko'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
      (4)                         
(2[o])                   (2)      
                (1)         (1[r])
         (0[\0])   (1[k])         

Оставшееся нераскодированное сообщение: 10101001111111000000000111100000000001011010111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 101 привел декодера к узлу с символом 'k', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
      (4)                         
(2[o])                   (2)      
                (1)         (1[r])
         (0[\0])   (2[k])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
      (5)                         
(2[o])                   (3)      
                (2)         (1[r])
         (0[\0])   (2[k])         

Требуется перевесить ветки:
       (2)      
(0[\0])   (2[k])

и

(1[r])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (5)                         
(2[o])         (3)                
         (1[r])          (2)      
                  (0[\0])   (2[k])

Требуется перевесить ветки:
(2[k])

и

(1[r])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (5)                         
(2[o])         (3)                
         (2[k])          (1)      
                  (0[\0])   (1[r])

Требуется перевесить ветки:
(2[k])

и

       (1)      
(0[\0])   (1[r])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (5)                         
(2[o])                   (3)      
                (1)         (2[k])
         (0[\0])   (1[r])         

Текущий результат декодирования сообщения: 'rokok'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
      (5)                         
(2[o])                   (3)      
                (1)         (2[k])
         (0[\0])   (1[r])         

Оставшееся нераскодированное сообщение: 01001111111000000000111100000000001011010111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 0 привел декодера к узлу с символом 'o', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
      (5)                         
(3[o])                   (3)      
                (1)         (2[k])
         (0[\0])   (1[r])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
      (6)                         
(3[o])                   (3)      
                (1)         (2[k])
         (0[\0])   (1[r])         

Текущий результат декодирования сообщения: 'rokoko'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
      (6)                         
(3[o])                   (3)      
                (1)         (2[k])
         (0[\0])   (1[r])         

Оставшееся нераскодированное сообщение: 1001111111000000000111100000000001011010111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 1111111000000000111100000000001011010111
Следующий набор бит: 111111 привел декодера к узлу с символом ' ' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: ' ':
      (6)                                  
(3[o])                            (3)      
                         (1)         (2[k])
                (0)         (1[r])         
         (0[\0])   (1[ ])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
      (7)                                  
(3[o])                            (4)      
                         (2)         (2[k])
                (1)         (1[r])         
         (0[\0])   (1[ ])                  

Текущий результат декодирования сообщения: 'rokoko '
---------------------------------
---------------------------------
Текущее дерево кодировщика:
      (7)                                  
(3[o])                            (4)      
                         (2)         (2[k])
                (1)         (1[r])         
         (0[\0])   (1[ ])                  

Оставшееся нераскодированное сообщение: 1000000000111100000000001011010111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 1000 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 000000111100000000001011010111
Следующий набор бит: 0000001 привел декодера к узлу с символом 'b' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'b':
      (7)                                           
(3[o])                                     (4)      
                                  (2)         (2[k])
                         (1)         (1[r])         
                (0)         (1[ ])                  
         (0[\0])   (1[b])                           

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
      (8)                                           
(3[o])                                     (5)      
                                  (3)         (2[k])
                         (2)         (1[r])         
                (1)         (1[ ])                  
         (0[\0])   (1[b])                           

Требуется перевесить ветки:
                (2)      
       (1)         (1[ ])
(0[\0])   (1[b])         

и

(1[r])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (8)                                           
(3[o])                                     (5)      
               (3)                            (2[k])
         (1[r])                   (2)               
                         (1)         (1[ ])         
                  (0[\0])   (1[b])                  

Требуется перевесить ветки:
      (3)                         
(1[r])                   (2)      
                (1)         (1[ ])
         (0[\0])   (1[b])         

и

(2[k])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (8)                                           
(3[o])         (5)                                  
         (2[k])         (3)                         
                  (1[r])                   (2)      
                                  (1)         (1[ ])
                           (0[\0])   (1[b])         

Текущий результат декодирования сообщения: 'rokoko b'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
      (8)                                           
(3[o])         (5)                                  
         (2[k])         (3)                         
                  (1[r])                   (2)      
                                  (1)         (1[ ])
                           (0[\0])   (1[b])         

Оставшееся нераскодированное сообщение: 11100000000001011010111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 11100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 000000001011010111
Следующий набор бит: 0000000 привел декодера к узлу с символом 'a' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'a':
      (8)                                                    
(3[o])         (5)                                           
         (2[k])         (3)                                  
                  (1[r])                            (2)      
                                           (1)         (1[ ])
                                  (0)         (1[b])         
                           (0[\0])   (1[a])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
      (9)                                                    
(3[o])         (6)                                           
         (2[k])         (4)                                  
                  (1[r])                            (3)      
                                           (2)         (1[ ])
                                  (1)         (1[b])         
                           (0[\0])   (1[a])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[b])
(0[\0])   (1[a])         

и

(1[r])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (9)                                                    
(3[o])         (6)                                           
         (2[k])                            (4)               
                                  (2)               (2)      
                         (1)         (1[b])   (1[r])   (1[ ])
                  (0[\0])   (1[a])                           

Требуется перевесить ветки:
                         (4)               
                (2)               (2)      
       (1)         (1[b])   (1[r])   (1[ ])
(0[\0])   (1[a])                           

и

(3[o])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                           (9)               
                         (4)                        (5)      
                (2)               (2)         (2[k])   (3[o])
       (1)         (1[b])   (1[r])   (1[ ])                  
(0[\0])   (1[a])                                             

Текущий результат декодирования сообщения: 'rokoko ba'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                           (9)               
                         (4)                        (5)      
                (2)               (2)         (2[k])   (3[o])
       (1)         (1[b])   (1[r])   (1[ ])                  
(0[\0])   (1[a])                                             

Оставшееся нераскодированное сообщение: 01011010111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 010 привел декодера к узлу с символом 'r', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                           (9)               
                         (4)                        (5)      
                (2)               (2)         (2[k])   (3[o])
       (1)         (1[b])   (2[r])   (1[ ])                  
(0[\0])   (1[a])                                             

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                           (10)               
                         (5)                         (5)      
                (2)               (3)          (2[k])   (3[o])
       (1)         (1[b])   (2[r])   (1[ ])                   
(0[\0])   (1[a])                                              

Требуется перевесить ветки:
(2[r])

и

(1[ ])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                           (10)               
                         (5)                         (5)      
                (2)               (3)          (2[k])   (3[o])
       (1)         (1[b])   (1[ ])   (2[r])                   
(0[\0])   (1[a])                                              

Требуется перевесить ветки:
      (3)      
(1[ ])   (2[r])

и

(2[k])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                  (10)                        
                         (4)                         (6)      
                (2)         (2[k])          (3)         (3[o])
       (1)         (1[b])             (1[ ])   (2[r])         
(0[\0])   (1[a])                                              

Текущий результат декодирования сообщения: 'rokoko bar'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                  (10)                        
                         (4)                         (6)      
                (2)         (2[k])          (3)         (3[o])
       (1)         (1[b])             (1[ ])   (2[r])         
(0[\0])   (1[a])                                              

Оставшееся нераскодированное сообщение: 11010111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 11 привел декодера к узлу с символом 'o', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                  (10)                        
                         (4)                         (6)      
                (2)         (2[k])          (3)         (4[o])
       (1)         (1[b])             (1[ ])   (2[r])         
(0[\0])   (1[a])                                              

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                  (11)                        
                         (4)                         (7)      
                (2)         (2[k])          (3)         (4[o])
       (1)         (1[b])             (1[ ])   (2[r])         
(0[\0])   (1[a])                                              

Текущий результат декодирования сообщения: 'rokoko baro'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                  (11)                        
                         (4)                         (7)      
                (2)         (2[k])          (3)         (4[o])
       (1)         (1[b])             (1[ ])   (2[r])         
(0[\0])   (1[a])                                              

Оставшееся нераскодированное сообщение: 010111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 01 привел декодера к узлу с символом 'k', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                  (11)                        
                         (4)                         (7)      
                (2)         (3[k])          (3)         (4[o])
       (1)         (1[b])             (1[ ])   (2[r])         
(0[\0])   (1[a])                                              

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                  (12)                        
                         (5)                         (7)      
                (2)         (3[k])          (3)         (4[o])
       (1)         (1[b])             (1[ ])   (2[r])         
(0[\0])   (1[a])                                              

Текущий результат декодирования сообщения: 'rokoko barok'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                  (12)                        
                         (5)                         (7)      
                (2)         (3[k])          (3)         (4[o])
       (1)         (1[b])             (1[ ])   (2[r])         
(0[\0])   (1[a])                                              

Оставшееся нераскодированное сообщение: 0111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 01 привел декодера к узлу с символом 'k', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                  (12)                        
                         (5)                         (7)      
                (2)         (4[k])          (3)         (4[o])
       (1)         (1[b])             (1[ ])   (2[r])         
(0[\0])   (1[a])                                              

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                  (13)                        
                         (6)                         (7)      
                (2)         (4[k])          (3)         (4[o])
       (1)         (1[b])             (1[ ])   (2[r])         
(0[\0])   (1[a])                                              

Требуется перевесить ветки:
(4[k])

и

      (3)      
(1[ ])   (2[r])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                           (13)               
                         (5)                         (8)      
                (2)               (3)          (4[k])   (4[o])
       (1)         (1[b])   (1[ ])   (2[r])                   
(0[\0])   (1[a])                                              

Текущий результат декодирования сообщения: 'rokoko barokk'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                           (13)               
                         (5)                         (8)      
                (2)               (3)          (4[k])   (4[o])
       (1)         (1[b])   (1[ ])   (2[r])                   
(0[\0])   (1[a])                                              

Оставшееся нераскодированное сообщение: 11

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 11 привел декодера к узлу с символом 'o', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                           (13)               
                         (5)                         (8)      
                (2)               (3)          (4[k])   (5[o])
       (1)         (1[b])   (1[ ])   (2[r])                   
(0[\0])   (1[a])                                              

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                           (14)               
                         (5)                         (9)      
                (2)               (3)          (4[k])   (5[o])
       (1)         (1[b])   (1[ ])   (2[r])                   
(0[\0])   (1[a])                                              

Текущий результат декодирования сообщения: 'rokoko barokko'
---------------------------------
Конец работы декодировщика.
