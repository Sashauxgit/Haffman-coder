Алфавит и сгенерированные специальные кода каждого символа:
a - 0000000
b - 0000001
c - 0000010
d - 0000011
e - 0000100
f - 0000101
g - 0000110
h - 0000111
i - 0001000
j - 0001001
k - 0001010
l - 0001011
m - 000110
n - 000111
o - 001000
p - 001001
q - 001010
r - 001011
s - 001100
t - 001101
u - 001110
v - 001111
w - 010000
x - 010001
y - 010010
z - 010011
A - 010100
B - 010101
C - 010110
D - 010111
E - 011000
F - 011001
G - 011010
H - 011011
I - 011100
J - 011101
K - 011110
L - 011111
M - 100000
N - 100001
O - 100010
P - 100011
Q - 100100
R - 100101
S - 100110
T - 100111
U - 101000
V - 101001
W - 101010
X - 101011
Y - 101100
Z - 101101
0 - 101110
1 - 101111
2 - 110000
3 - 110001
4 - 110010
5 - 110011
6 - 110100
7 - 110101
8 - 110110
9 - 110111
. - 111000
, - 111001
! - 111010
? - 111011
: - 111100
( - 111101
) - 111110
  - 111111


Промежуточные данные:
Начало работы декодировщика: на вход декодеру подается последовательность бит:
100111000001110000001001001111110000001110111000100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001
---------------------------------
Текущее дерево кодировщика:
(0[\0])

Оставшееся нераскодированное сообщение: 100111000001110000001001001111110000001110111000100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит:  привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 100111000001110000001001001111110000001110111000100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001
Следующий набор бит: 100111 привел декодера к узлу с символом 'T' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'T':
       (0)      
(0[\0])   (1[T])

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
       (1)      
(0[\0])   (1[T])

Текущий результат декодирования сообщения: 'T'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
       (1)      
(0[\0])   (1[T])

Оставшееся нераскодированное сообщение: 000001110000001001001111110000001110111000100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 0 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 00001110000001001001111110000001110111000100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001
Следующий набор бит: 0000111 привел декодера к узлу с символом 'h' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'h':
                (1)      
       (0)         (1[T])
(0[\0])   (1[h])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                (2)      
       (1)         (1[T])
(0[\0])   (1[h])         

Текущий результат декодирования сообщения: 'Th'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                (2)      
       (1)         (1[T])
(0[\0])   (1[h])         

Оставшееся нераскодированное сообщение: 0000001001001111110000001110111000100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 00 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 00001001001111110000001110111000100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001
Следующий набор бит: 0000100 привел декодера к узлу с символом 'e' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'e':
                         (2)      
                (1)         (1[T])
       (0)         (1[h])         
(0[\0])   (1[e])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                         (3)      
                (2)         (1[T])
       (1)         (1[h])         
(0[\0])   (1[e])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[h])
(0[\0])   (1[e])         

и

(1[T])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (3)                         
(1[T])                   (2)      
                (1)         (1[h])
         (0[\0])   (1[e])         

Текущий результат декодирования сообщения: 'The'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
      (3)                         
(1[T])                   (2)      
                (1)         (1[h])
         (0[\0])   (1[e])         

Оставшееся нераскодированное сообщение: 1001111110000001110111000100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 1111110000001110111000100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001
Следующий набор бит: 111111 привел декодера к узлу с символом ' ' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: ' ':
      (3)                                  
(1[T])                            (2)      
                         (1)         (1[h])
                (0)         (1[e])         
         (0[\0])   (1[ ])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
      (4)                                  
(1[T])                            (3)      
                         (2)         (1[h])
                (1)         (1[e])         
         (0[\0])   (1[ ])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[e])
(0[\0])   (1[ ])         

и

(1[T])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                         (4)               
                (2)               (2)      
       (1)         (1[e])   (1[T])   (1[h])
(0[\0])   (1[ ])                           

Текущий результат декодирования сообщения: 'The '
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                         (4)               
                (2)               (2)      
       (1)         (1[e])   (1[T])   (1[h])
(0[\0])   (1[ ])                           

Оставшееся нераскодированное сообщение: 0000001110111000100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 000 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0001110111000100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001
Следующий набор бит: 000111 привел декодера к узлу с символом 'n' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'n':
                                  (4)               
                         (2)               (2)      
                (1)         (1[e])   (1[T])   (1[h])
       (0)         (1[ ])                           
(0[\0])   (1[n])                                    

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                  (5)               
                         (3)               (2)      
                (2)         (1[e])   (1[T])   (1[h])
       (1)         (1[ ])                           
(0[\0])   (1[n])                                    

Требуется перевесить ветки:
                (2)      
       (1)         (1[ ])
(0[\0])   (1[n])         

и

(1[h])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
               (5)                                  
      (2)               (3)                         
(1[h])   (1[e])   (1[T])                   (2)      
                                  (1)         (1[ ])
                           (0[\0])   (1[n])         

Текущий результат декодирования сообщения: 'The n'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
               (5)                                  
      (2)               (3)                         
(1[h])   (1[e])   (1[T])                   (2)      
                                  (1)         (1[ ])
                           (0[\0])   (1[n])         

Оставшееся нераскодированное сообщение: 0111000100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 01 привел декодера к узлу с символом 'e', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
               (5)                                  
      (2)               (3)                         
(1[h])   (2[e])   (1[T])                   (2)      
                                  (1)         (1[ ])
                           (0[\0])   (1[n])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
               (6)                                  
      (3)               (3)                         
(1[h])   (2[e])   (1[T])                   (2)      
                                  (1)         (1[ ])
                           (0[\0])   (1[n])         

Требуется перевесить ветки:
(2[e])

и

(1[T])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
               (6)                                  
      (2)               (4)                         
(1[h])   (1[T])   (2[e])                   (2)      
                                  (1)         (1[ ])
                           (0[\0])   (1[n])         

Текущий результат декодирования сообщения: 'The ne'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
               (6)                                  
      (2)               (4)                         
(1[h])   (1[T])   (2[e])                   (2)      
                                  (1)         (1[ ])
                           (0[\0])   (1[n])         

Оставшееся нераскодированное сообщение: 11000100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 1100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0100001110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001
Следующий набор бит: 010000 привел декодера к узлу с символом 'w' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'w':
               (6)                                           
      (2)               (4)                                  
(1[h])   (1[T])   (2[e])                            (2)      
                                           (1)         (1[ ])
                                  (0)         (1[n])         
                           (0[\0])   (1[w])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
               (7)                                           
      (2)               (5)                                  
(1[h])   (1[T])   (2[e])                            (3)      
                                           (2)         (1[ ])
                                  (1)         (1[n])         
                           (0[\0])   (1[w])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[n])
(0[\0])   (1[w])         

и

(1[T])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                  (7)                        
      (3)                                  (4)               
(1[h])                   (2)         (2[e])         (2)      
                (1)         (1[n])            (1[T])   (1[ ])
         (0[\0])   (1[w])                                    

Текущий результат декодирования сообщения: 'The new'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                  (7)                        
      (3)                                  (4)               
(1[h])                   (2)         (2[e])         (2)      
                (1)         (1[n])            (1[T])   (1[ ])
         (0[\0])   (1[w])                                    

Оставшееся нераскодированное сообщение: 1110100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 111 привел декодера к узлу с символом ' ', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                  (7)                        
      (3)                                  (4)               
(1[h])                   (2)         (2[e])         (2)      
                (1)         (1[n])            (1[T])   (2[ ])
         (0[\0])   (1[w])                                    

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                  (8)                        
      (3)                                  (5)               
(1[h])                   (2)         (2[e])         (3)      
                (1)         (1[n])            (1[T])   (2[ ])
         (0[\0])   (1[w])                                    

Требуется перевесить ветки:
(2[ ])

и

(1[h])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                  (8)                        
      (4)                                  (4)               
(2[ ])                   (2)         (2[e])         (2)      
                (1)         (1[n])            (1[T])   (1[h])
         (0[\0])   (1[w])                                    

Текущий результат декодирования сообщения: 'The new '
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                  (8)                        
      (4)                                  (4)               
(2[ ])                   (2)         (2[e])         (2)      
                (1)         (1[n])            (1[T])   (1[h])
         (0[\0])   (1[w])                                    

Оставшееся нераскодированное сообщение: 0100110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 0100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 110000111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001
Следующий набор бит: 110000 привел декодера к узлу с символом '2' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: '2':
                                           (8)                        
      (4)                                           (4)               
(2[ ])                            (2)         (2[e])         (2)      
                         (1)         (1[n])            (1[T])   (1[h])
                (0)         (1[w])                                    
         (0[\0])   (1[2])                                             

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                           (9)                        
      (5)                                           (4)               
(2[ ])                            (3)         (2[e])         (2)      
                         (2)         (1[n])            (1[T])   (1[h])
                (1)         (1[w])                                    
         (0[\0])   (1[2])                                             

Требуется перевесить ветки:
                (2)      
       (1)         (1[w])
(0[\0])   (1[2])         

и

(1[h])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (9)                                           
      (4)                        (5)                                  
(2[ ])         (2)         (2[e])         (3)                         
         (1[h])   (1[n])            (1[T])                   (2)      
                                                    (1)         (1[w])
                                             (0[\0])   (1[2])         

Текущий результат декодирования сообщения: 'The new 2'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (9)                                           
      (4)                        (5)                                  
(2[ ])         (2)         (2[e])         (3)                         
         (1[h])   (1[n])            (1[T])                   (2)      
                                                    (1)         (1[w])
                                             (0[\0])   (1[2])         

Оставшееся нераскодированное сообщение: 111001011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 11100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 1011101101110001011110010000010010111001000000000010000010111101001110100000110100111011111001
Следующий набор бит: 101110 привел декодера к узлу с символом '0' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: '0':
                        (9)                                                    
      (4)                        (5)                                           
(2[ ])         (2)         (2[e])         (3)                                  
         (1[h])   (1[n])            (1[T])                            (2)      
                                                             (1)         (1[w])
                                                    (0)         (1[2])         
                                             (0[\0])   (1[0])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (10)                                                    
      (4)                         (6)                                           
(2[ ])         (2)          (2[e])         (4)                                  
         (1[h])   (1[n])             (1[T])                            (3)      
                                                              (2)         (1[w])
                                                     (1)         (1[2])         
                                              (0[\0])   (1[0])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[2])
(0[\0])   (1[0])         

и

(1[T])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (10)                                                    
      (4)                         (6)                                           
(2[ ])         (2)          (2[e])                            (4)               
         (1[h])   (1[n])                             (2)               (2)      
                                            (1)         (1[2])   (1[T])   (1[w])
                                     (0[\0])   (1[0])                           

Текущий результат декодирования сообщения: 'The new 20'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (10)                                                    
      (4)                         (6)                                           
(2[ ])         (2)          (2[e])                            (4)               
         (1[h])   (1[n])                             (2)               (2)      
                                            (1)         (1[2])   (1[T])   (1[w])
                                     (0[\0])   (1[0])                           

Оставшееся нераскодированное сообщение: 1101110001011110010000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 1101 привел декодера к узлу с символом '2', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                        (10)                                                    
      (4)                         (6)                                           
(2[ ])         (2)          (2[e])                            (4)               
         (1[h])   (1[n])                             (2)               (2)      
                                            (1)         (2[2])   (1[T])   (1[w])
                                     (0[\0])   (1[0])                           

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (11)                                                    
      (4)                         (7)                                           
(2[ ])         (2)          (2[e])                            (5)               
         (1[h])   (1[n])                             (3)               (2)      
                                            (1)         (2[2])   (1[T])   (1[w])
                                     (0[\0])   (1[0])                           

Требуется перевесить ветки:
(2[2])

и

(1[n])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (11)                                                    
      (5)                         (6)                                           
(2[ ])         (3)          (2[e])                            (4)               
         (1[h])   (2[2])                             (2)               (2)      
                                            (1)         (1[n])   (1[T])   (1[w])
                                     (0[\0])   (1[0])                           

Требуется перевесить ветки:
      (3)      
(1[h])   (2[2])

и

(2[e])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
               (11)                                                             
      (4)                         (7)                                           
(2[ ])   (2[e])          (3)                                  (4)               
                   (1[h])   (2[2])                   (2)               (2)      
                                            (1)         (1[n])   (1[T])   (1[w])
                                     (0[\0])   (1[0])                           

Текущий результат декодирования сообщения: 'The new 202'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
               (11)                                                             
      (4)                         (7)                                           
(2[ ])   (2[e])          (3)                                  (4)               
                   (1[h])   (2[2])                   (2)               (2)      
                                            (1)         (1[n])   (1[T])   (1[w])
                                     (0[\0])   (1[0])                           

Оставшееся нераскодированное сообщение: 110001011110010000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 11000 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 1011110010000010010111001000000000010000010111101001110100000110100111011111001
Следующий набор бит: 101111 привел декодера к узлу с символом '1' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: '1':
               (11)                                                                      
      (4)                         (7)                                                    
(2[ ])   (2[e])          (3)                                           (4)               
                   (1[h])   (2[2])                            (2)               (2)      
                                                     (1)         (1[n])   (1[T])   (1[w])
                                            (0)         (1[0])                           
                                     (0[\0])   (1[1])                                    

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
               (12)                                                                      
      (4)                         (8)                                                    
(2[ ])   (2[e])          (3)                                           (5)               
                   (1[h])   (2[2])                            (3)               (2)      
                                                     (2)         (1[n])   (1[T])   (1[w])
                                            (1)         (1[0])                           
                                     (0[\0])   (1[1])                                    

Требуется перевесить ветки:
                (2)      
       (1)         (1[0])
(0[\0])   (1[1])         

и

(1[h])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
               (12)                                                                      
      (4)                                            (8)                                 
(2[ ])   (2[e])                             (4)                        (4)               
                                   (2)         (2[2])         (2)               (2)      
                          (1)         (1[0])            (1[h])   (1[n])   (1[T])   (1[w])
                   (0[\0])   (1[1])                                                      

Текущий результат декодирования сообщения: 'The new 2021'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
               (12)                                                                      
      (4)                                            (8)                                 
(2[ ])   (2[e])                             (4)                        (4)               
                                   (2)         (2[2])         (2)               (2)      
                          (1)         (1[0])            (1[h])   (1[n])   (1[T])   (1[w])
                   (0[\0])   (1[1])                                                      

Оставшееся нераскодированное сообщение: 0010000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 00 привел декодера к узлу с символом ' ', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
               (12)                                                                      
      (4)                                            (8)                                 
(3[ ])   (2[e])                             (4)                        (4)               
                                   (2)         (2[2])         (2)               (2)      
                          (1)         (1[0])            (1[h])   (1[n])   (1[T])   (1[w])
                   (0[\0])   (1[1])                                                      

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
               (13)                                                                      
      (5)                                            (8)                                 
(3[ ])   (2[e])                             (4)                        (4)               
                                   (2)         (2[2])         (2)               (2)      
                          (1)         (1[0])            (1[h])   (1[n])   (1[T])   (1[w])
                   (0[\0])   (1[1])                                                      

Требуется перевесить ветки:
(3[ ])

и

(2[e])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
               (13)                                                                      
      (5)                                            (8)                                 
(2[e])   (3[ ])                             (4)                        (4)               
                                   (2)         (2[2])         (2)               (2)      
                          (1)         (1[0])            (1[h])   (1[n])   (1[T])   (1[w])
                   (0[\0])   (1[1])                                                      

Текущий результат декодирования сообщения: 'The new 2021 '
---------------------------------
---------------------------------
Текущее дерево кодировщика:
               (13)                                                                      
      (5)                                            (8)                                 
(2[e])   (3[ ])                             (4)                        (4)               
                                   (2)         (2[2])         (2)               (2)      
                          (1)         (1[0])            (1[h])   (1[n])   (1[T])   (1[w])
                   (0[\0])   (1[1])                                                      

Оставшееся нераскодированное сообщение: 10000010010111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 10000 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 010010111001000000000010000010111101001110100000110100111011111001
Следующий набор бит: 010010 привел декодера к узлу с символом 'y' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'y':
               (13)                                                                               
      (5)                                                     (8)                                 
(2[e])   (3[ ])                                      (4)                        (4)               
                                            (2)         (2[2])         (2)               (2)      
                                   (1)         (1[0])            (1[h])   (1[n])   (1[T])   (1[w])
                          (0)         (1[1])                                                      
                   (0[\0])   (1[y])                                                               

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
               (14)                                                                               
      (5)                                                     (9)                                 
(2[e])   (3[ ])                                      (5)                        (4)               
                                            (3)         (2[2])         (2)               (2)      
                                   (2)         (1[0])            (1[h])   (1[n])   (1[T])   (1[w])
                          (1)         (1[1])                                                      
                   (0[\0])   (1[y])                                                               

Требуется перевесить ветки:
                (2)      
       (1)         (1[1])
(0[\0])   (1[y])         

и

(1[w])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
               (14)                                                                               
      (5)                                  (9)                                                    
(2[e])   (3[ ])                   (4)                        (5)                                  
                         (2)         (2[2])         (2)               (3)                         
                   (1[w])   (1[0])            (1[h])   (1[n])   (1[T])                   (2)      
                                                                                (1)         (1[1])
                                                                         (0[\0])   (1[y])         

Требуется перевесить ветки:
      (3)                         
(1[T])                   (2)      
                (1)         (1[1])
         (0[\0])   (1[y])         

и

(2[e])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                           (14)                                                   
                                  (6)                                  (8)                        
      (3)                            (3[ ])                   (4)                        (4)      
(1[T])                   (2)                         (2)         (2[2])         (2)         (2[e])
                (1)         (1[1])             (1[w])   (1[0])            (1[h])   (1[n])         
         (0[\0])   (1[y])                                                                         

Текущий результат декодирования сообщения: 'The new 2021 y'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                           (14)                                                   
                                  (6)                                  (8)                        
      (3)                            (3[ ])                   (4)                        (4)      
(1[T])                   (2)                         (2)         (2[2])         (2)         (2[e])
                (1)         (1[1])             (1[w])   (1[0])            (1[h])   (1[n])         
         (0[\0])   (1[y])                                                                         

Оставшееся нераскодированное сообщение: 111001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 111 привел декодера к узлу с символом 'e', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                           (14)                                                   
                                  (6)                                  (8)                        
      (3)                            (3[ ])                   (4)                        (4)      
(1[T])                   (2)                         (2)         (2[2])         (2)         (3[e])
                (1)         (1[1])             (1[w])   (1[0])            (1[h])   (1[n])         
         (0[\0])   (1[y])                                                                         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                           (15)                                                   
                                  (6)                                  (9)                        
      (3)                            (3[ ])                   (4)                        (5)      
(1[T])                   (2)                         (2)         (2[2])         (2)         (3[e])
                (1)         (1[1])             (1[w])   (1[0])            (1[h])   (1[n])         
         (0[\0])   (1[y])                                                                         

Текущий результат декодирования сообщения: 'The new 2021 ye'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                           (15)                                                   
                                  (6)                                  (9)                        
      (3)                            (3[ ])                   (4)                        (5)      
(1[T])                   (2)                         (2)         (2[2])         (2)         (3[e])
                (1)         (1[1])             (1[w])   (1[0])            (1[h])   (1[n])         
         (0[\0])   (1[y])                                                                         

Оставшееся нераскодированное сообщение: 001000000000010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 00100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0000000010000010111101001110100000110100111011111001
Следующий набор бит: 0000000 привел декодера к узлу с символом 'a' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'a':
                                                    (15)                                                   
                                           (6)                                  (9)                        
      (3)                                     (3[ ])                   (4)                        (5)      
(1[T])                            (2)                         (2)         (2[2])         (2)         (3[e])
                         (1)         (1[1])             (1[w])   (1[0])            (1[h])   (1[n])         
                (0)         (1[y])                                                                         
         (0[\0])   (1[a])                                                                                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                                    (16)                                                   
                                           (7)                                  (9)                        
      (4)                                     (3[ ])                   (4)                        (5)      
(1[T])                            (3)                         (2)         (2[2])         (2)         (3[e])
                         (2)         (1[1])             (1[w])   (1[0])            (1[h])   (1[n])         
                (1)         (1[y])                                                                         
         (0[\0])   (1[a])                                                                                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[y])
(0[\0])   (1[a])         

и

(1[T])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                    (16)                                                   
                                           (7)                                  (9)                        
                         (4)                  (3[ ])                   (4)                        (5)      
                (2)               (2)                         (2)         (2[2])         (2)         (3[e])
       (1)         (1[y])   (1[T])   (1[1])             (1[w])   (1[0])            (1[h])   (1[n])         
(0[\0])   (1[a])                                                                                           

Требуется перевесить ветки:
                         (4)               
                (2)               (2)      
       (1)         (1[y])   (1[T])   (1[1])
(0[\0])   (1[a])                           

и

(3[ ])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                    (16)                                                   
      (7)                                                                       (9)                        
(3[ ])                            (4)                                  (4)                        (5)      
                         (2)               (2)                (2)         (2[2])         (2)         (3[e])
                (1)         (1[y])   (1[T])   (1[1])    (1[w])   (1[0])            (1[h])   (1[n])         
         (0[\0])   (1[a])                                                                                  

Текущий результат декодирования сообщения: 'The new 2021 yea'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                                    (16)                                                   
      (7)                                                                       (9)                        
(3[ ])                            (4)                                  (4)                        (5)      
                         (2)               (2)                (2)         (2[2])         (2)         (3[e])
                (1)         (1[y])   (1[T])   (1[1])    (1[w])   (1[0])            (1[h])   (1[n])         
         (0[\0])   (1[a])                                                                                  

Оставшееся нераскодированное сообщение: 010000010111101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 01000 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0010111101001110100000110100111011111001
Следующий набор бит: 001011 привел декодера к узлу с символом 'r' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'r':
                                                             (16)                                                   
      (7)                                                                                (9)                        
(3[ ])                                     (4)                                  (4)                        (5)      
                                  (2)               (2)                (2)         (2[2])         (2)         (3[e])
                         (1)         (1[y])   (1[T])   (1[1])    (1[w])   (1[0])            (1[h])   (1[n])         
                (0)         (1[a])                                                                                  
         (0[\0])   (1[r])                                                                                           

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                                             (17)                                                   
      (8)                                                                                (9)                        
(3[ ])                                     (5)                                  (4)                        (5)      
                                  (3)               (2)                (2)         (2[2])         (2)         (3[e])
                         (2)         (1[y])   (1[T])   (1[1])    (1[w])   (1[0])            (1[h])   (1[n])         
                (1)         (1[a])                                                                                  
         (0[\0])   (1[r])                                                                                           

Требуется перевесить ветки:
                (2)      
       (1)         (1[a])
(0[\0])   (1[r])         

и

(1[n])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                          (17)                                                                       
      (7)                                                             (10)                                           
(3[ ])                  (4)                                  (4)                                            (6)      
               (2)               (2)                (2)         (2[2])          (3)                            (3[e])
         (1[n])   (1[y])   (1[T])   (1[1])    (1[w])   (1[0])             (1[h])                   (2)               
                                                                                          (1)         (1[a])         
                                                                                   (0[\0])   (1[r])                  

Текущий результат декодирования сообщения: 'The new 2021 year'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                          (17)                                                                       
      (7)                                                             (10)                                           
(3[ ])                  (4)                                  (4)                                            (6)      
               (2)               (2)                (2)         (2[2])          (3)                            (3[e])
         (1[n])   (1[y])   (1[T])   (1[1])    (1[w])   (1[0])             (1[h])                   (2)               
                                                                                          (1)         (1[a])         
                                                                                   (0[\0])   (1[r])                  

Оставшееся нераскодированное сообщение: 1101001110100000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 110100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 1110100000110100111011111001
Следующий набор бит: 111010 привел декодера к узлу с символом '!' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: '!':
                                          (17)                                                                                
      (7)                                                             (10)                                                    
(3[ ])                  (4)                                  (4)                                                     (6)      
               (2)               (2)                (2)         (2[2])          (3)                                     (3[e])
         (1[n])   (1[y])   (1[T])   (1[1])    (1[w])   (1[0])             (1[h])                            (2)               
                                                                                                   (1)         (1[a])         
                                                                                          (0)         (1[r])                  
                                                                                   (0[\0])   (1[!])                           

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                          (18)                                                                                
      (7)                                                             (11)                                                    
(3[ ])                  (4)                                  (4)                                                     (7)      
               (2)               (2)                (2)         (2[2])          (4)                                     (3[e])
         (1[n])   (1[y])   (1[T])   (1[1])    (1[w])   (1[0])             (1[h])                            (3)               
                                                                                                   (2)         (1[a])         
                                                                                          (1)         (1[r])                  
                                                                                   (0[\0])   (1[!])                           

Требуется перевесить ветки:
                (2)      
       (1)         (1[r])
(0[\0])   (1[!])         

и

(1[h])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                          (18)                                                                                
      (7)                                                             (11)                                                    
(3[ ])                  (4)                                  (4)                                                     (7)      
               (2)               (2)                (2)         (2[2])                             (4)                  (3[e])
         (1[n])   (1[y])   (1[T])   (1[1])    (1[w])   (1[0])                             (2)               (2)               
                                                                                 (1)         (1[r])   (1[h])   (1[a])         
                                                                          (0[\0])   (1[!])                                    

Требуется перевесить ветки:
                         (4)               
                (2)               (2)      
       (1)         (1[r])   (1[h])   (1[a])
(0[\0])   (1[!])                           

и

(3[ ])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                                               (18)                                           
                                           (8)                                                             (10)               
                         (4)                                 (4)                                  (4)                (6)      
                (2)               (2)               (2)               (2)                (2)         (2[2])    (3[ ])   (3[e])
       (1)         (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])    (1[w])   (1[0])                            
(0[\0])   (1[!])                                                                                                              

Текущий результат декодирования сообщения: 'The new 2021 year!'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                                                               (18)                                           
                                           (8)                                                             (10)               
                         (4)                                 (4)                                  (4)                (6)      
                (2)               (2)               (2)               (2)                (2)         (2[2])    (3[ ])   (3[e])
       (1)         (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])    (1[w])   (1[0])                            
(0[\0])   (1[!])                                                                                                              

Оставшееся нераскодированное сообщение: 0000110100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 00001 привел декодера к узлу с символом '!', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                                                               (18)                                           
                                           (8)                                                             (10)               
                         (4)                                 (4)                                  (4)                (6)      
                (2)               (2)               (2)               (2)                (2)         (2[2])    (3[ ])   (3[e])
       (1)         (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])    (1[w])   (1[0])                            
(0[\0])   (2[!])                                                                                                              

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                                                               (19)                                           
                                           (9)                                                             (10)               
                         (5)                                 (4)                                  (4)                (6)      
                (3)               (2)               (2)               (2)                (2)         (2[2])    (3[ ])   (3[e])
       (2)         (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])    (1[w])   (1[0])                            
(0[\0])   (2[!])                                                                                                              

Требуется перевесить ветки:
       (2)      
(0[\0])   (2[!])

и

(1[0])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                                     (19)                                                     
                                 (8)                                                                       (11)               
               (4)                                 (4)                                            (5)                (6)      
      (2)               (2)               (2)               (2)                (3)                   (2[2])    (3[ ])   (3[e])
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])    (1[w])          (2)                                  
                                                                                  (0[\0])   (2[!])                            

Требуется перевесить ветки:
(2[!])

и

(1[w])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                                     (19)                                                     
                                 (8)                                                                       (11)               
               (4)                                 (4)                                            (5)                (6)      
      (2)               (2)               (2)               (2)                (3)                   (2[2])    (3[ ])   (3[e])
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])    (2[!])          (1)                                  
                                                                                  (0[\0])   (1[w])                            

Требуется перевесить ветки:
(2[!])

и

       (1)      
(0[\0])   (1[w])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                                     (19)                                                     
                                 (8)                                                                       (11)               
               (4)                                 (4)                                            (5)                (6)      
      (2)               (2)               (2)               (2)                          (3)         (2[2])    (3[ ])   (3[e])
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])           (1)         (2[!])                            
                                                                         (0[\0])   (1[w])                                     

Требуется перевесить ветки:
                (3)      
       (1)         (2[!])
(0[\0])   (1[w])         

и

(2[2])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                                     (19)                                                     
                                 (8)                                                                       (11)               
               (4)                                 (4)                         (5)                                   (6)      
      (2)               (2)               (2)               (2)          (2[2])                   (3)          (3[ ])   (3[e])
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])                    (1)         (2[!])                   
                                                                                  (0[\0])   (1[w])                            

Текущий результат декодирования сообщения: 'The new 2021 year!!'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                                                     (19)                                                     
                                 (8)                                                                       (11)               
               (4)                                 (4)                         (5)                                   (6)      
      (2)               (2)               (2)               (2)          (2[2])                   (3)          (3[ ])   (3[e])
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])                    (1)         (2[!])                   
                                                                                  (0[\0])   (1[w])                            

Оставшееся нераскодированное сообщение: 10100111011111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 10100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 111011111001
Следующий набор бит: 111011 привел декодера к узлу с символом '?' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: '?':
                                                                     (19)                                                              
                                 (8)                                                                                (11)               
               (4)                                 (4)                         (5)                                            (6)      
      (2)               (2)               (2)               (2)          (2[2])                            (3)          (3[ ])   (3[e])
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])                             (1)         (2[!])                   
                                                                                         (0)         (1[w])                            
                                                                                  (0[\0])   (1[?])                                     

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                                                     (20)                                                              
                                 (8)                                                                                (12)               
               (4)                                 (4)                         (6)                                            (6)      
      (2)               (2)               (2)               (2)          (2[2])                            (4)          (3[ ])   (3[e])
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])                             (2)         (2[!])                   
                                                                                         (1)         (1[w])                            
                                                                                  (0[\0])   (1[?])                                     

Требуется перевесить ветки:
                         (4)      
                (2)         (2[!])
       (1)         (1[w])         
(0[\0])   (1[?])                  

и

(3[e])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                                     (20)                                                              
                                 (8)                                                    (12)                                           
               (4)                                 (4)                         (5)                (7)                                  
      (2)               (2)               (2)               (2)          (2[2])   (3[e])    (3[ ])                            (4)      
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])                                                (2)         (2[!])
                                                                                                            (1)         (1[w])         
                                                                                                     (0[\0])   (1[?])                  

Текущий результат декодирования сообщения: 'The new 2021 year!!?'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                                                     (20)                                                              
                                 (8)                                                    (12)                                           
               (4)                                 (4)                         (5)                (7)                                  
      (2)               (2)               (2)               (2)          (2[2])   (3[e])    (3[ ])                            (4)      
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])                                                (2)         (2[!])
                                                                                                            (1)         (1[w])         
                                                                                                     (0[\0])   (1[?])                  

Оставшееся нераскодированное сообщение: 111001

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 111001 привел декодера к узлу с символом '?', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                                                     (20)                                                              
                                 (8)                                                    (12)                                           
               (4)                                 (4)                         (5)                (7)                                  
      (2)               (2)               (2)               (2)          (2[2])   (3[e])    (3[ ])                            (4)      
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])                                                (2)         (2[!])
                                                                                                            (1)         (1[w])         
                                                                                                     (0[\0])   (2[?])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                                                     (21)                                                              
                                 (8)                                                    (13)                                           
               (4)                                 (4)                         (5)                (8)                                  
      (2)               (2)               (2)               (2)          (2[2])   (3[e])    (3[ ])                            (5)      
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])   (1[1])                                                (3)         (2[!])
                                                                                                            (2)         (1[w])         
                                                                                                     (0[\0])   (2[?])                  

Требуется перевесить ветки:
       (2)      
(0[\0])   (2[?])

и

(1[1])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                                               (21)                                                    
                                 (9)                                                              (12)                                 
               (4)                                 (5)                                   (5)                (7)                        
      (2)               (2)               (2)               (3)                    (2[2])   (3[e])    (3[ ])                  (4)      
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (1[T])          (2)                                            (2)         (2[!])
                                                               (0[\0])   (2[?])                                (1[1])   (1[w])         

Требуется перевесить ветки:
(2[?])

и

(1[T])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                                               (21)                                                    
                                 (9)                                                              (12)                                 
               (4)                                 (5)                                   (5)                (7)                        
      (2)               (2)               (2)               (3)                    (2[2])   (3[e])    (3[ ])                  (4)      
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])   (2[?])          (1)                                            (2)         (2[!])
                                                               (0[\0])   (1[T])                                (1[1])   (1[w])         

Требуется перевесить ветки:
(2[?])

и

       (1)      
(0[\0])   (1[T])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                                               (21)                                                    
                                 (9)                                                              (12)                                 
               (4)                                 (5)                                   (5)                (7)                        
      (2)               (2)               (2)                         (3)          (2[2])   (3[e])    (3[ ])                  (4)      
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])          (1)         (2[?])                                      (2)         (2[!])
                                                      (0[\0])   (1[T])                                         (1[1])   (1[w])         

Требуется перевесить ветки:
                (3)      
       (1)         (2[?])
(0[\0])   (1[T])         

и

(2[2])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                            (21)                                                                       
                                 (8)                                                              (13)                                 
               (4)                                 (4)                                   (6)                (7)                        
      (2)               (2)               (2)         (2[2])                    (3)         (3[e])    (3[ ])                  (4)      
(1[0])   (1[r])   (1[h])   (1[a])   (1[n])   (1[y])                    (1)         (2[?])                            (2)         (2[!])
                                                                (0[\0])   (1[T])                               (1[1])   (1[w])         

Текущий результат декодирования сообщения: 'The new 2021 year!!??'
---------------------------------
Конец работы декодировщика.
