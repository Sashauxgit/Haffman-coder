Алфавит и сгенерированные специальные кода каждого символа:
a - 0000000
b - 0000001
c - 0000010
d - 0000011
e - 0000100
f - 0000101
g - 0000110
h - 0000111
i - 0001000
j - 0001001
k - 0001010
l - 0001011
m - 000110
n - 000111
o - 001000
p - 001001
q - 001010
r - 001011
s - 001100
t - 001101
u - 001110
v - 001111
w - 010000
x - 010001
y - 010010
z - 010011
A - 010100
B - 010101
C - 010110
D - 010111
E - 011000
F - 011001
G - 011010
H - 011011
I - 011100
J - 011101
K - 011110
L - 011111
M - 100000
N - 100001
O - 100010
P - 100011
Q - 100100
R - 100101
S - 100110
T - 100111
U - 101000
V - 101001
W - 101010
X - 101011
Y - 101100
Z - 101101
0 - 101110
1 - 101111
2 - 110000
3 - 110001
4 - 110010
5 - 110011
6 - 110100
7 - 110101
8 - 110110
9 - 110111
. - 111000
, - 111001
! - 111010
? - 111011
: - 111100
( - 111101
) - 111110
  - 111111


Промежуточные данные:
Начало работы декодировщика: на вход декодеру подается последовательность бит:
01101100000100000001011101110001000110011100110001111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010
---------------------------------
Текущее дерево кодировщика:
(0[\0])

Оставшееся нераскодированное сообщение: 01101100000100000001011101110001000110011100110001111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит:  привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 01101100000100000001011101110001000110011100110001111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010
Следующий набор бит: 011011 привел декодера к узлу с символом 'H' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'H':
       (0)      
(0[\0])   (1[H])

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
       (1)      
(0[\0])   (1[H])

Текущий результат декодирования сообщения: 'H'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
       (1)      
(0[\0])   (1[H])

Оставшееся нераскодированное сообщение: 00000100000001011101110001000110011100110001111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 0 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0000100000001011101110001000110011100110001111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010
Следующий набор бит: 0000100 привел декодера к узлу с символом 'e' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'e':
                (1)      
       (0)         (1[H])
(0[\0])   (1[e])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                (2)      
       (1)         (1[H])
(0[\0])   (1[e])         

Текущий результат декодирования сообщения: 'He'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                (2)      
       (1)         (1[H])
(0[\0])   (1[e])         

Оставшееся нераскодированное сообщение: 000001011101110001000110011100110001111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 00 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0001011101110001000110011100110001111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010
Следующий набор бит: 0001011 привел декодера к узлу с символом 'l' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'l':
                         (2)      
                (1)         (1[H])
       (0)         (1[e])         
(0[\0])   (1[l])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                         (3)      
                (2)         (1[H])
       (1)         (1[e])         
(0[\0])   (1[l])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[e])
(0[\0])   (1[l])         

и

(1[H])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (3)                         
(1[H])                   (2)      
                (1)         (1[e])
         (0[\0])   (1[l])         

Текущий результат декодирования сообщения: 'Hel'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
      (3)                         
(1[H])                   (2)      
                (1)         (1[e])
         (0[\0])   (1[l])         

Оставшееся нераскодированное сообщение: 101110001000110011100110001111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 101 привел декодера к узлу с символом 'l', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
      (3)                         
(1[H])                   (2)      
                (1)         (1[e])
         (0[\0])   (2[l])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
      (4)                         
(1[H])                   (3)      
                (2)         (1[e])
         (0[\0])   (2[l])         

Требуется перевесить ветки:
       (2)      
(0[\0])   (2[l])

и

(1[H])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                (4)               
       (2)               (2)      
(0[\0])   (2[l])   (1[H])   (1[e])

Требуется перевесить ветки:
(2[l])

и

(1[e])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                (4)               
       (1)               (3)      
(0[\0])   (1[e])   (1[H])   (2[l])

Требуется перевесить ветки:
(2[l])

и

       (1)      
(0[\0])   (1[e])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (4)                         
(2[l])         (2)                
         (1[H])          (1)      
                  (0[\0])   (1[e])

Текущий результат декодирования сообщения: 'Hell'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
      (4)                         
(2[l])         (2)                
         (1[H])          (1)      
                  (0[\0])   (1[e])

Оставшееся нераскодированное сообщение: 110001000110011100110001111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 110 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 001000110011100110001111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010
Следующий набор бит: 001000 привел декодера к узлу с символом 'o' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'o':
      (4)                                  
(2[l])         (2)                         
         (1[H])                   (1)      
                         (0)         (1[e])
                  (0[\0])   (1[o])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
      (5)                                  
(2[l])         (3)                         
         (1[H])                   (2)      
                         (1)         (1[e])
                  (0[\0])   (1[o])         

Текущий результат декодирования сообщения: 'Hello'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
      (5)                                  
(2[l])         (3)                         
         (1[H])                   (2)      
                         (1)         (1[e])
                  (0[\0])   (1[o])         

Оставшееся нераскодированное сообщение: 110011100110001111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 1100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 11100110001111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010
Следующий набор бит: 111001 привел декодера к узлу с символом ',' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: ',':
      (5)                                           
(2[l])         (3)                                  
         (1[H])                            (2)      
                                  (1)         (1[e])
                         (0)         (1[o])         
                  (0[\0])   (1[,])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
      (6)                                           
(2[l])         (4)                                  
         (1[H])                            (3)      
                                  (2)         (1[e])
                         (1)         (1[o])         
                  (0[\0])   (1[,])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[o])
(0[\0])   (1[,])         

и

(1[H])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (6)                                           
(2[l])                            (4)               
                         (2)               (2)      
                (1)         (1[o])   (1[H])   (1[e])
         (0[\0])   (1[,])                           

Текущий результат декодирования сообщения: 'Hello,'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
      (6)                                           
(2[l])                            (4)               
                         (2)               (2)      
                (1)         (1[o])   (1[H])   (1[e])
         (0[\0])   (1[,])                           

Оставшееся нераскодированное сообщение: 10001111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 1000 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 1111110100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010
Следующий набор бит: 111111 привел декодера к узлу с символом ' ' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: ' ':
      (6)                                                    
(2[l])                                     (4)               
                                  (2)               (2)      
                         (1)         (1[o])   (1[H])   (1[e])
                (0)         (1[,])                           
         (0[\0])   (1[ ])                                    

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
      (7)                                                    
(2[l])                                     (5)               
                                  (3)               (2)      
                         (2)         (1[o])   (1[H])   (1[e])
                (1)         (1[,])                           
         (0[\0])   (1[ ])                                    

Требуется перевесить ветки:
                (2)      
       (1)         (1[,])
(0[\0])   (1[ ])         

и

(1[e])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (7)                                                    
(2[l])                  (5)                                  
               (2)               (3)                         
         (1[e])   (1[o])   (1[H])                   (2)      
                                           (1)         (1[,])
                                    (0[\0])   (1[ ])         

Требуется перевесить ветки:
      (3)                         
(1[H])                   (2)      
                (1)         (1[,])
         (0[\0])   (1[ ])         

и

(2[l])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                  (7)                        
      (3)                                           (4)      
(1[H])                   (2)               (2)         (2[l])
                (1)         (1[,])   (1[e])   (1[o])         
         (0[\0])   (1[ ])                                    

Текущий результат декодирования сообщения: 'Hello, '
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                  (7)                        
      (3)                                           (4)      
(1[H])                   (2)               (2)         (2[l])
                (1)         (1[,])   (1[e])   (1[o])         
         (0[\0])   (1[ ])                                    

Оставшееся нераскодированное сообщение: 0100000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 0100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 000110000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010
Следующий набор бит: 000110 привел декодера к узлу с символом 'm' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'm':
                                           (7)                        
      (3)                                                    (4)      
(1[H])                            (2)               (2)         (2[l])
                         (1)         (1[,])   (1[e])   (1[o])         
                (0)         (1[ ])                                    
         (0[\0])   (1[m])                                             

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                           (8)                        
      (4)                                                    (4)      
(1[H])                            (3)               (2)         (2[l])
                         (2)         (1[,])   (1[e])   (1[o])         
                (1)         (1[ ])                                    
         (0[\0])   (1[m])                                             

Требуется перевесить ветки:
                (2)      
       (1)         (1[ ])
(0[\0])   (1[m])         

и

(1[H])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                           (8)                        
                         (4)                                 (4)      
                (2)               (2)               (2)         (2[l])
       (1)         (1[ ])   (1[H])   (1[,])   (1[e])   (1[o])         
(0[\0])   (1[m])                                                      

Текущий результат декодирования сообщения: 'Hello, m'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                           (8)                        
                         (4)                                 (4)      
                (2)               (2)               (2)         (2[l])
       (1)         (1[ ])   (1[H])   (1[,])   (1[e])   (1[o])         
(0[\0])   (1[m])                                                      

Оставшееся нераскодированное сообщение: 000001001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 0000 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 01001000111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010
Следующий набор бит: 010010 привел декодера к узлу с символом 'y' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'y':
                                                    (8)                        
                                  (4)                                 (4)      
                         (2)               (2)               (2)         (2[l])
                (1)         (1[ ])   (1[H])   (1[,])   (1[e])   (1[o])         
       (0)         (1[m])                                                      
(0[\0])   (1[y])                                                               

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                                    (9)                        
                                  (5)                                 (4)      
                         (3)               (2)               (2)         (2[l])
                (2)         (1[ ])   (1[H])   (1[,])   (1[e])   (1[o])         
       (1)         (1[m])                                                      
(0[\0])   (1[y])                                                               

Требуется перевесить ветки:
                (2)      
       (1)         (1[m])
(0[\0])   (1[y])         

и

(1[o])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                 (9)                                           
               (4)                                                    (5)      
      (2)               (2)               (3)                            (2[l])
(1[o])   (1[ ])   (1[H])   (1[,])   (1[e])                   (2)               
                                                    (1)         (1[m])         
                                             (0[\0])   (1[y])                  

Требуется перевесить ветки:
      (3)                         
(1[e])                   (2)      
                (1)         (1[m])
         (0[\0])   (1[y])         

и

(2[l])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                 (9)                                           
               (4)                        (5)                                  
      (2)               (2)         (2[l])         (3)                         
(1[o])   (1[ ])   (1[H])   (1[,])            (1[e])                   (2)      
                                                             (1)         (1[m])
                                                      (0[\0])   (1[y])         

Текущий результат декодирования сообщения: 'Hello, my'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                 (9)                                           
               (4)                        (5)                                  
      (2)               (2)         (2[l])         (3)                         
(1[o])   (1[ ])   (1[H])   (1[,])            (1[e])                   (2)      
                                                             (1)         (1[m])
                                                      (0[\0])   (1[y])         

Оставшееся нераскодированное сообщение: 00111100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 001 привел декодера к узлу с символом ' ', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                 (9)                                           
               (4)                        (5)                                  
      (2)               (2)         (2[l])         (3)                         
(1[o])   (2[ ])   (1[H])   (1[,])            (1[e])                   (2)      
                                                             (1)         (1[m])
                                                      (0[\0])   (1[y])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                 (10)                                           
               (5)                         (5)                                  
      (3)               (2)          (2[l])         (3)                         
(1[o])   (2[ ])   (1[H])   (1[,])             (1[e])                   (2)      
                                                              (1)         (1[m])
                                                       (0[\0])   (1[y])         

Требуется перевесить ветки:
(2[ ])

и

(1[e])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                 (10)                                           
               (4)                         (6)                                  
      (2)               (2)          (2[l])         (4)                         
(1[o])   (1[e])   (1[H])   (1[,])             (2[ ])                   (2)      
                                                              (1)         (1[m])
                                                       (0[\0])   (1[y])         

Текущий результат декодирования сообщения: 'Hello, my '
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                 (10)                                           
               (4)                         (6)                                  
      (2)               (2)          (2[l])         (4)                         
(1[o])   (1[e])   (1[H])   (1[,])             (2[ ])                   (2)      
                                                              (1)         (1[m])
                                                       (0[\0])   (1[y])         

Оставшееся нераскодированное сообщение: 11100000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 11100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 000111101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010
Следующий набор бит: 000111 привел декодера к узлу с символом 'n' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'n':
                                 (10)                                                    
               (4)                         (6)                                           
      (2)               (2)          (2[l])         (4)                                  
(1[o])   (1[e])   (1[H])   (1[,])             (2[ ])                            (2)      
                                                                       (1)         (1[m])
                                                              (0)         (1[y])         
                                                       (0[\0])   (1[n])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                 (11)                                                    
               (4)                         (7)                                           
      (2)               (2)          (2[l])         (5)                                  
(1[o])   (1[e])   (1[H])   (1[,])             (2[ ])                            (3)      
                                                                       (2)         (1[m])
                                                              (1)         (1[y])         
                                                       (0[\0])   (1[n])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[y])
(0[\0])   (1[n])         

и

(1[,])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                    (11)                                 
               (5)                                            (6)                        
      (2)               (3)                             (2[l])         (4)               
(1[o])   (1[e])   (1[H])                   (2)                   (2[ ])         (2)      
                                  (1)         (1[y])                      (1[,])   (1[m])
                           (0[\0])   (1[n])                                              

Требуется перевесить ветки:
      (3)                         
(1[H])                   (2)      
                (1)         (1[y])
         (0[\0])   (1[n])         

и

(2[l])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (11)                                                             
               (4)                                            (7)                        
      (2)         (2[l])          (3)                                  (4)               
(1[o])   (1[e])             (1[H])                   (2)         (2[ ])         (2)      
                                            (1)         (1[y])            (1[,])   (1[m])
                                     (0[\0])   (1[n])                                    

Текущий результат декодирования сообщения: 'Hello, my n'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (11)                                                             
               (4)                                            (7)                        
      (2)         (2[l])          (3)                                  (4)               
(1[o])   (1[e])             (1[H])                   (2)         (2[ ])         (2)      
                                            (1)         (1[y])            (1[,])   (1[m])
                                     (0[\0])   (1[n])                                    

Оставшееся нераскодированное сообщение: 101000000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 10100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0000000111111111101000000010001111000011001110000010011000111101000000111110111100101100111010
Следующий набор бит: 0000000 привел декодера к узлу с символом 'a' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'a':
                        (11)                                                                      
               (4)                                                     (7)                        
      (2)         (2[l])          (3)                                           (4)               
(1[o])   (1[e])             (1[H])                            (2)         (2[ ])         (2)      
                                                     (1)         (1[y])            (1[,])   (1[m])
                                            (0)         (1[n])                                    
                                     (0[\0])   (1[a])                                             

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (12)                                                                      
               (4)                                                     (8)                        
      (2)         (2[l])          (4)                                           (4)               
(1[o])   (1[e])             (1[H])                            (3)         (2[ ])         (2)      
                                                     (2)         (1[y])            (1[,])   (1[m])
                                            (1)         (1[n])                                    
                                     (0[\0])   (1[a])                                             

Требуется перевесить ветки:
                (2)      
       (1)         (1[n])
(0[\0])   (1[a])         

и

(1[H])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (12)                                                                      
               (4)                                                     (8)                        
      (2)         (2[l])                             (4)                        (4)               
(1[o])   (1[e])                             (2)               (2)         (2[ ])         (2)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (1[m])
                            (0[\0])   (1[a])                                                      

Текущий результат декодирования сообщения: 'Hello, my na'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (12)                                                                      
               (4)                                                     (8)                        
      (2)         (2[l])                             (4)                        (4)               
(1[o])   (1[e])                             (2)               (2)         (2[ ])         (2)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (1[m])
                            (0[\0])   (1[a])                                                      

Оставшееся нераскодированное сообщение: 111111111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 1111 привел декодера к узлу с символом 'm', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                        (12)                                                                      
               (4)                                                     (8)                        
      (2)         (2[l])                             (4)                        (4)               
(1[o])   (1[e])                             (2)               (2)         (2[ ])         (2)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (2[m])
                            (0[\0])   (1[a])                                                      

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (13)                                                                      
               (4)                                                     (9)                        
      (2)         (2[l])                             (4)                        (5)               
(1[o])   (1[e])                             (2)               (2)         (2[ ])         (3)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (2[m])
                            (0[\0])   (1[a])                                                      

Требуется перевесить ветки:
(2[m])

и

(1[e])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (13)                                                                      
               (5)                                                     (8)                        
      (3)         (2[l])                             (4)                        (4)               
(1[o])   (2[m])                             (2)               (2)         (2[ ])         (2)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (1[e])
                            (0[\0])   (1[a])                                                      

Требуется перевесить ветки:
      (3)      
(1[o])   (2[m])

и

(2[l])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (13)                                                                      
      (5)                                                              (8)                        
(2[l])         (3)                                   (4)                        (4)               
         (1[o])   (2[m])                    (2)               (2)         (2[ ])         (2)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (1[e])
                            (0[\0])   (1[a])                                                      

Текущий результат декодирования сообщения: 'Hello, my nam'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (13)                                                                      
      (5)                                                              (8)                        
(2[l])         (3)                                   (4)                        (4)               
         (1[o])   (2[m])                    (2)               (2)         (2[ ])         (2)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (1[e])
                            (0[\0])   (1[a])                                                      

Оставшееся нераскодированное сообщение: 11111101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 1111 привел декодера к узлу с символом 'e', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                        (13)                                                                      
      (5)                                                              (8)                        
(2[l])         (3)                                   (4)                        (4)               
         (1[o])   (2[m])                    (2)               (2)         (2[ ])         (2)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (2[e])
                            (0[\0])   (1[a])                                                      

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (14)                                                                      
      (5)                                                              (9)                        
(2[l])         (3)                                   (4)                        (5)               
         (1[o])   (2[m])                    (2)               (2)         (2[ ])         (3)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (2[e])
                            (0[\0])   (1[a])                                                      

Требуется перевесить ветки:
(2[e])

и

(1[o])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (14)                                                                      
      (6)                                                              (8)                        
(2[l])         (4)                                   (4)                        (4)               
         (2[e])   (2[m])                    (2)               (2)         (2[ ])         (2)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (1[o])
                            (0[\0])   (1[a])                                                      

Текущий результат декодирования сообщения: 'Hello, my name'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (14)                                                                      
      (6)                                                              (8)                        
(2[l])         (4)                                   (4)                        (4)               
         (2[e])   (2[m])                    (2)               (2)         (2[ ])         (2)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (1[o])
                            (0[\0])   (1[a])                                                      

Оставшееся нераскодированное сообщение: 1101000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 110 привел декодера к узлу с символом ' ', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                        (14)                                                                      
      (6)                                                              (8)                        
(2[l])         (4)                                   (4)                        (4)               
         (2[e])   (2[m])                    (2)               (2)         (3[ ])         (2)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (1[o])
                            (0[\0])   (1[a])                                                      

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (15)                                                                      
      (6)                                                              (9)                        
(2[l])         (4)                                   (4)                        (5)               
         (2[e])   (2[m])                    (2)               (2)         (3[ ])         (2)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (1[o])
                            (0[\0])   (1[a])                                                      

Требуется перевесить ветки:
(3[ ])

и

(2[l])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (15)                                                                      
      (7)                                                              (8)                        
(3[ ])         (4)                                   (4)                        (4)               
         (2[e])   (2[m])                    (2)               (2)         (2[l])         (2)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (1[o])
                            (0[\0])   (1[a])                                                      

Текущий результат декодирования сообщения: 'Hello, my name '
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (15)                                                                      
      (7)                                                              (8)                        
(3[ ])         (4)                                   (4)                        (4)               
         (2[e])   (2[m])                    (2)               (2)         (2[l])         (2)      
                                   (1)         (1[n])   (1[H])   (1[y])            (1[,])   (1[o])
                            (0[\0])   (1[a])                                                      

Оставшееся нераскодированное сообщение: 1000000010001111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 10000 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 00010001111000011001110000010011000111101000000111110111100101100111010
Следующий набор бит: 0001000 привел декодера к узлу с символом 'i' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'i':
                        (15)                                                                               
      (7)                                                                       (8)                        
(3[ ])         (4)                                            (4)                        (4)               
         (2[e])   (2[m])                             (2)               (2)         (2[l])         (2)      
                                            (1)         (1[n])   (1[H])   (1[y])            (1[,])   (1[o])
                                   (0)         (1[a])                                                      
                            (0[\0])   (1[i])                                                               

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (16)                                                                               
      (7)                                                                       (9)                        
(3[ ])         (4)                                            (5)                        (4)               
         (2[e])   (2[m])                             (3)               (2)         (2[l])         (2)      
                                            (2)         (1[n])   (1[H])   (1[y])            (1[,])   (1[o])
                                   (1)         (1[a])                                                      
                            (0[\0])   (1[i])                                                               

Требуется перевесить ветки:
                (2)      
       (1)         (1[a])
(0[\0])   (1[i])         

и

(1[o])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (16)                                                                               
      (7)                                                    (9)                                           
(3[ ])         (4)                         (4)                        (5)                                  
         (2[e])   (2[m])          (2)               (2)         (2[l])         (3)                         
                            (1[o])   (1[n])   (1[H])   (1[y])            (1[,])                   (2)      
                                                                                         (1)         (1[a])
                                                                                  (0[\0])   (1[i])         

Текущий результат декодирования сообщения: 'Hello, my name i'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (16)                                                                               
      (7)                                                    (9)                                           
(3[ ])         (4)                         (4)                        (5)                                  
         (2[e])   (2[m])          (2)               (2)         (2[l])         (3)                         
                            (1[o])   (1[n])   (1[H])   (1[y])            (1[,])                   (2)      
                                                                                         (1)         (1[a])
                                                                                  (0[\0])   (1[i])         

Оставшееся нераскодированное сообщение: 1111000011001110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 111100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0011001110000010011000111101000000111110111100101100111010
Следующий набор бит: 001100 привел декодера к узлу с символом 's' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 's':
                        (16)                                                                                        
      (7)                                                    (9)                                                    
(3[ ])         (4)                         (4)                        (5)                                           
         (2[e])   (2[m])          (2)               (2)         (2[l])         (3)                                  
                            (1[o])   (1[n])   (1[H])   (1[y])            (1[,])                            (2)      
                                                                                                  (1)         (1[a])
                                                                                         (0)         (1[i])         
                                                                                  (0[\0])   (1[s])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (17)                                                                                         
      (7)                                                    (10)                                                    
(3[ ])         (4)                         (4)                         (6)                                           
         (2[e])   (2[m])          (2)               (2)          (2[l])         (4)                                  
                            (1[o])   (1[n])   (1[H])   (1[y])             (1[,])                            (3)      
                                                                                                   (2)         (1[a])
                                                                                          (1)         (1[i])         
                                                                                   (0[\0])   (1[s])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[i])
(0[\0])   (1[s])         

и

(1[,])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (17)                                                                                         
      (7)                                                    (10)                                                    
(3[ ])         (4)                         (4)                         (6)                                           
         (2[e])   (2[m])          (2)               (2)          (2[l])                            (4)               
                            (1[o])   (1[n])   (1[H])   (1[y])                             (2)               (2)      
                                                                                 (1)         (1[i])   (1[,])   (1[a])
                                                                          (0[\0])   (1[s])                           

Требуется перевесить ветки:
                         (4)               
                (2)               (2)      
       (1)         (1[i])   (1[,])   (1[a])
(0[\0])   (1[s])                           

и

(3[ ])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                             (17)                                                   
                                           (8)                                                    (9)               
                         (4)                        (4)                         (4)                        (5)      
                (2)               (2)         (2[e])   (2[m])          (2)               (2)         (2[l])   (3[ ])
       (1)         (1[i])   (1[,])   (1[a])                      (1[o])   (1[n])   (1[H])   (1[y])                  
(0[\0])   (1[s])                                                                                                    

Текущий результат декодирования сообщения: 'Hello, my name is'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                                             (17)                                                   
                                           (8)                                                    (9)               
                         (4)                        (4)                         (4)                        (5)      
                (2)               (2)         (2[e])   (2[m])          (2)               (2)         (2[l])   (3[ ])
       (1)         (1[i])   (1[,])   (1[a])                      (1[o])   (1[n])   (1[H])   (1[y])                  
(0[\0])   (1[s])                                                                                                    

Оставшееся нераскодированное сообщение: 1110000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 111 привел декодера к узлу с символом ' ', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                                             (17)                                                   
                                           (8)                                                    (9)               
                         (4)                        (4)                         (4)                        (5)      
                (2)               (2)         (2[e])   (2[m])          (2)               (2)         (2[l])   (4[ ])
       (1)         (1[i])   (1[,])   (1[a])                      (1[o])   (1[n])   (1[H])   (1[y])                  
(0[\0])   (1[s])                                                                                                    

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                                             (18)                                                    
                                           (8)                                                    (10)               
                         (4)                        (4)                         (4)                         (6)      
                (2)               (2)         (2[e])   (2[m])          (2)               (2)          (2[l])   (4[ ])
       (1)         (1[i])   (1[,])   (1[a])                      (1[o])   (1[n])   (1[H])   (1[y])                   
(0[\0])   (1[s])                                                                                                     

Текущий результат декодирования сообщения: 'Hello, my name is '
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                                             (18)                                                    
                                           (8)                                                    (10)               
                         (4)                        (4)                         (4)                         (6)      
                (2)               (2)         (2[e])   (2[m])          (2)               (2)          (2[l])   (4[ ])
       (1)         (1[i])   (1[,])   (1[a])                      (1[o])   (1[n])   (1[H])   (1[y])                   
(0[\0])   (1[s])                                                                                                     

Оставшееся нераскодированное сообщение: 0000010011000111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 00000 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 10011000111101000000111110111100101100111010
Следующий набор бит: 100110 привел декодера к узлу с символом 'S' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'S':
                                                                      (18)                                                    
                                                    (8)                                                    (10)               
                                  (4)                        (4)                         (4)                         (6)      
                         (2)               (2)         (2[e])   (2[m])          (2)               (2)          (2[l])   (4[ ])
                (1)         (1[i])   (1[,])   (1[a])                      (1[o])   (1[n])   (1[H])   (1[y])                   
       (0)         (1[s])                                                                                                     
(0[\0])   (1[S])                                                                                                              

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                                                      (19)                                                    
                                                    (9)                                                    (10)               
                                  (5)                        (4)                         (4)                         (6)      
                         (3)               (2)         (2[e])   (2[m])          (2)               (2)          (2[l])   (4[ ])
                (2)         (1[i])   (1[,])   (1[a])                      (1[o])   (1[n])   (1[H])   (1[y])                   
       (1)         (1[s])                                                                                                     
(0[\0])   (1[S])                                                                                                              

Требуется перевесить ветки:
                (2)      
       (1)         (1[s])
(0[\0])   (1[S])         

и

(1[y])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                   (19)                                                                       
                                 (8)                                                                       (11)               
               (4)                        (4)                         (5)                                            (6)      
      (2)               (2)         (2[e])   (2[m])          (2)               (3)                             (2[l])   (4[ ])
(1[y])   (1[i])   (1[,])   (1[a])                      (1[o])   (1[n])   (1[H])                   (2)                         
                                                                                         (1)         (1[s])                   
                                                                                  (0[\0])   (1[S])                            

Требуется перевесить ветки:
      (3)                         
(1[H])                   (2)      
                (1)         (1[s])
         (0[\0])   (1[S])         

и

(2[l])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                   (19)                                                                       
                                 (8)                                           (11)                                           
               (4)                        (4)                         (4)                                            (7)      
      (2)               (2)         (2[e])   (2[m])          (2)         (2[l])          (3)                            (4[ ])
(1[y])   (1[i])   (1[,])   (1[a])                      (1[o])   (1[n])             (1[H])                   (2)               
                                                                                                   (1)         (1[s])         
                                                                                            (0[\0])   (1[S])                  

Текущий результат декодирования сообщения: 'Hello, my name is S'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                                   (19)                                                                       
                                 (8)                                           (11)                                           
               (4)                        (4)                         (4)                                            (7)      
      (2)               (2)         (2[e])   (2[m])          (2)         (2[l])          (3)                            (4[ ])
(1[y])   (1[i])   (1[,])   (1[a])                      (1[o])   (1[n])             (1[H])                   (2)               
                                                                                                   (1)         (1[s])         
                                                                                            (0[\0])   (1[S])                  

Оставшееся нераскодированное сообщение: 00111101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 0011 привел декодера к узлу с символом 'a', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                                   (19)                                                                       
                                 (8)                                           (11)                                           
               (4)                        (4)                         (4)                                            (7)      
      (2)               (2)         (2[e])   (2[m])          (2)         (2[l])          (3)                            (4[ ])
(1[y])   (1[i])   (1[,])   (2[a])                      (1[o])   (1[n])             (1[H])                   (2)               
                                                                                                   (1)         (1[s])         
                                                                                            (0[\0])   (1[S])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                                   (20)                                                                       
                                 (9)                                           (11)                                           
               (5)                        (4)                         (4)                                            (7)      
      (2)               (3)         (2[e])   (2[m])          (2)         (2[l])          (3)                            (4[ ])
(1[y])   (1[i])   (1[,])   (2[a])                      (1[o])   (1[n])             (1[H])                   (2)               
                                                                                                   (1)         (1[s])         
                                                                                            (0[\0])   (1[S])                  

Требуется перевесить ветки:
(2[a])

и

(1[H])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                   (20)                                                                       
                                 (8)                                           (12)                                           
               (4)                        (4)                         (4)                                            (8)      
      (2)               (2)         (2[e])   (2[m])          (2)         (2[l])          (4)                            (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                      (1[o])   (1[n])             (2[a])                   (2)               
                                                                                                   (1)         (1[s])         
                                                                                            (0[\0])   (1[S])                  

Текущий результат декодирования сообщения: 'Hello, my name is Sa'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                                   (20)                                                                       
                                 (8)                                           (12)                                           
               (4)                        (4)                         (4)                                            (8)      
      (2)               (2)         (2[e])   (2[m])          (2)         (2[l])          (4)                            (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                      (1[o])   (1[n])             (2[a])                   (2)               
                                                                                                   (1)         (1[s])         
                                                                                            (0[\0])   (1[S])                  

Оставшееся нераскодированное сообщение: 1101000000111110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 110100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0000111110111100101100111010
Следующий набор бит: 0000111 привел декодера к узлу с символом 'h' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'h':
                                                   (20)                                                                                
                                 (8)                                           (12)                                                    
               (4)                        (4)                         (4)                                                     (8)      
      (2)               (2)         (2[e])   (2[m])          (2)         (2[l])          (4)                                     (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                      (1[o])   (1[n])             (2[a])                            (2)               
                                                                                                            (1)         (1[s])         
                                                                                                   (0)         (1[S])                  
                                                                                            (0[\0])   (1[h])                           

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                                   (21)                                                                                
                                 (8)                                           (13)                                                    
               (4)                        (4)                         (4)                                                     (9)      
      (2)               (2)         (2[e])   (2[m])          (2)         (2[l])          (5)                                     (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                      (1[o])   (1[n])             (2[a])                            (3)               
                                                                                                            (2)         (1[s])         
                                                                                                   (1)         (1[S])                  
                                                                                            (0[\0])   (1[h])                           

Требуется перевесить ветки:
                (2)      
       (1)         (1[S])
(0[\0])   (1[h])         

и

(1[n])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                   (21)                                                                                
                                 (8)                                                              (13)                                 
               (4)                        (4)                                            (5)                                  (8)      
      (2)               (2)         (2[e])   (2[m])          (3)                            (2[l])          (4)                  (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                      (1[o])                   (2)                   (2[a])         (2)               
                                                                       (1)         (1[S])                      (1[n])   (1[s])         
                                                                (0[\0])   (1[h])                                                       

Требуется перевесить ветки:
      (3)                         
(1[o])                   (2)      
                (1)         (1[S])
         (0[\0])   (1[h])         

и

(2[l])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                   (21)                                                                                
                                 (8)                                                              (13)                                 
               (4)                        (4)                (5)                                                              (8)      
      (2)               (2)         (2[e])   (2[m])    (2[l])         (3)                                   (4)                  (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                               (1[o])                   (2)          (2[a])         (2)               
                                                                                (1)         (1[S])             (1[n])   (1[s])         
                                                                         (0[\0])   (1[h])                                              

Текущий результат декодирования сообщения: 'Hello, my name is Sah'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                                   (21)                                                                                
                                 (8)                                                              (13)                                 
               (4)                        (4)                (5)                                                              (8)      
      (2)               (2)         (2[e])   (2[m])    (2[l])         (3)                                   (4)                  (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                               (1[o])                   (2)          (2[a])         (2)               
                                                                                (1)         (1[S])             (1[n])   (1[s])         
                                                                         (0[\0])   (1[h])                                              

Оставшееся нераскодированное сообщение: 110111100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 11011 привел декодера к узлу с символом 's', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                                   (21)                                                                                
                                 (8)                                                              (13)                                 
               (4)                        (4)                (5)                                                              (8)      
      (2)               (2)         (2[e])   (2[m])    (2[l])         (3)                                   (4)                  (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                               (1[o])                   (2)          (2[a])         (2)               
                                                                                (1)         (1[S])             (1[n])   (2[s])         
                                                                         (0[\0])   (1[h])                                              

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                                   (22)                                                                                
                                 (8)                                                              (14)                                 
               (4)                        (4)                (5)                                                              (9)      
      (2)               (2)         (2[e])   (2[m])    (2[l])         (3)                                   (5)                  (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                               (1[o])                   (2)          (2[a])         (3)               
                                                                                (1)         (1[S])             (1[n])   (2[s])         
                                                                         (0[\0])   (1[h])                                              

Требуется перевесить ветки:
(2[s])

и

(1[o])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                   (22)                                                                                
                                 (8)                                                              (14)                                 
               (4)                        (4)                (6)                                                              (8)      
      (2)               (2)         (2[e])   (2[m])    (2[l])         (4)                                   (4)                  (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                               (2[s])                   (2)          (2[a])         (2)               
                                                                                (1)         (1[S])             (1[n])   (1[o])         
                                                                         (0[\0])   (1[h])                                              

Текущий результат декодирования сообщения: 'Hello, my name is Sahs'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                                   (22)                                                                                
                                 (8)                                                              (14)                                 
               (4)                        (4)                (6)                                                              (8)      
      (2)               (2)         (2[e])   (2[m])    (2[l])         (4)                                   (4)                  (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                               (2[s])                   (2)          (2[a])         (2)               
                                                                                (1)         (1[S])             (1[n])   (1[o])         
                                                                         (0[\0])   (1[h])                                              

Оставшееся нераскодированное сообщение: 1100101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 1100 привел декодера к узлу с символом 'a', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                                   (22)                                                                                
                                 (8)                                                              (14)                                 
               (4)                        (4)                (6)                                                              (8)      
      (2)               (2)         (2[e])   (2[m])    (2[l])         (4)                                   (4)                  (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                               (2[s])                   (2)          (3[a])         (2)               
                                                                                (1)         (1[S])             (1[n])   (1[o])         
                                                                         (0[\0])   (1[h])                                              

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                                   (23)                                                                                
                                 (8)                                                              (15)                                 
               (4)                        (4)                (6)                                                              (9)      
      (2)               (2)         (2[e])   (2[m])    (2[l])         (4)                                   (5)                  (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                               (2[s])                   (2)          (3[a])         (2)               
                                                                                (1)         (1[S])             (1[n])   (1[o])         
                                                                         (0[\0])   (1[h])                                              

Требуется перевесить ветки:
(3[a])

и

(2[l])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                   (23)                                                                                
                                 (8)                                                              (15)                                 
               (4)                        (4)                (7)                                                              (8)      
      (2)               (2)         (2[e])   (2[m])    (3[a])         (4)                                   (4)                  (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                               (2[s])                   (2)          (2[l])         (2)               
                                                                                (1)         (1[S])             (1[n])   (1[o])         
                                                                         (0[\0])   (1[h])                                              

Текущий результат декодирования сообщения: 'Hello, my name is Sahsa'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                                   (23)                                                                                
                                 (8)                                                              (15)                                 
               (4)                        (4)                (7)                                                              (8)      
      (2)               (2)         (2[e])   (2[m])    (3[a])         (4)                                   (4)                  (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                               (2[s])                   (2)          (2[l])         (2)               
                                                                                (1)         (1[S])             (1[n])   (1[o])         
                                                                         (0[\0])   (1[h])                                              

Оставшееся нераскодированное сообщение: 101100111010

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 101100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 111010
Следующий набор бит: 111010 привел декодера к узлу с символом '!' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: '!':
                                                   (23)                                                                                         
                                 (8)                                                                       (15)                                 
               (4)                        (4)                (7)                                                                       (8)      
      (2)               (2)         (2[e])   (2[m])    (3[a])         (4)                                            (4)                  (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                               (2[s])                            (2)          (2[l])         (2)               
                                                                                         (1)         (1[S])             (1[n])   (1[o])         
                                                                                (0)         (1[h])                                              
                                                                         (0[\0])   (1[!])                                                       

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                                   (24)                                                                                         
                                 (8)                                                                       (16)                                 
               (4)                        (4)                (8)                                                                       (8)      
      (2)               (2)         (2[e])   (2[m])    (3[a])         (5)                                            (4)                  (4[ ])
(1[y])   (1[i])   (1[,])   (1[H])                               (2[s])                            (3)          (2[l])         (2)               
                                                                                         (2)         (1[S])             (1[n])   (1[o])         
                                                                                (1)         (1[h])                                              
                                                                         (0[\0])   (1[!])                                                       

Требуется перевесить ветки:
                (2)      
       (1)         (1[h])
(0[\0])   (1[!])         

и

(1[H])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                                      (24)                                                                      
                                                    (9)                                                    (15)                                 
               (5)                                           (4)                (7)                                                    (8)      
      (2)               (3)                            (2[e])   (2[m])    (3[a])         (4)                         (4)                  (4[ ])
(1[y])   (1[i])   (1[,])                   (2)                                     (2[s])         (2)          (2[l])         (2)               
                                  (1)         (1[h])                                        (1[H])   (1[S])             (1[n])   (1[o])         
                           (0[\0])   (1[!])                                                                                                     

Требуется перевесить ветки:
      (3)                         
(1[,])                   (2)      
                (1)         (1[h])
         (0[\0])   (1[!])         

и

(2[m])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                                                      (24)                                                                      
                        (9)                                                                                (15)                                 
               (4)               (5)                                            (7)                                                    (8)      
      (2)         (2[m])   (2[e])         (3)                             (3[a])         (4)                         (4)                  (4[ ])
(1[y])   (1[i])                     (1[,])                   (2)                   (2[s])         (2)          (2[l])         (2)               
                                                    (1)         (1[h])                      (1[H])   (1[S])             (1[n])   (1[o])         
                                             (0[\0])   (1[!])                                                                                   

Текущий результат декодирования сообщения: 'Hello, my name is Sahsa!'
---------------------------------
Конец работы декодировщика.
