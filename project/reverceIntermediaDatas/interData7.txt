Алфавит и сгенерированные специальные кода каждого символа:
a - 0000000
b - 0000001
c - 0000010
d - 0000011
e - 0000100
f - 0000101
g - 0000110
h - 0000111
i - 0001000
j - 0001001
k - 0001010
l - 0001011
m - 000110
n - 000111
o - 001000
p - 001001
q - 001010
r - 001011
s - 001100
t - 001101
u - 001110
v - 001111
w - 010000
x - 010001
y - 010010
z - 010011
A - 010100
B - 010101
C - 010110
D - 010111
E - 011000
F - 011001
G - 011010
H - 011011
I - 011100
J - 011101
K - 011110
L - 011111
M - 100000
N - 100001
O - 100010
P - 100011
Q - 100100
R - 100101
S - 100110
T - 100111
U - 101000
V - 101001
W - 101010
X - 101011
Y - 101100
Z - 101101
0 - 101110
1 - 101111
2 - 110000
3 - 110001
4 - 110010
5 - 110011
6 - 110100
7 - 110101
8 - 110110
9 - 110111
. - 111000
, - 111001
! - 111010
? - 111011
: - 111100
( - 111101
) - 111110
  - 111111


Промежуточные данные:
Начало работы декодировщика: на вход декодеру подается последовательность бит:
00110100000110001010001000110010001011001100001110100010010101011101100010010110000011001010000000001001100000000111
---------------------------------
Текущее дерево кодировщика:
(0[\0])

Оставшееся нераскодированное сообщение: 00110100000110001010001000110010001011001100001110100010010101011101100010010110000011001010000000001001100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит:  привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 00110100000110001010001000110010001011001100001110100010010101011101100010010110000011001010000000001001100000000111
Следующий набор бит: 001101 привел декодера к узлу с символом 't' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 't':
       (0)      
(0[\0])   (1[t])

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
       (1)      
(0[\0])   (1[t])

Текущий результат декодирования сообщения: 't'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
       (1)      
(0[\0])   (1[t])

Оставшееся нераскодированное сообщение: 00000110001010001000110010001011001100001110100010010101011101100010010110000011001010000000001001100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 0 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0000110001010001000110010001011001100001110100010010101011101100010010110000011001010000000001001100000000111
Следующий набор бит: 0000110 привел декодера к узлу с символом 'g' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'g':
                (1)      
       (0)         (1[t])
(0[\0])   (1[g])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                (2)      
       (1)         (1[t])
(0[\0])   (1[g])         

Текущий результат декодирования сообщения: 'tg'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                (2)      
       (1)         (1[t])
(0[\0])   (1[g])         

Оставшееся нераскодированное сообщение: 001010001000110010001011001100001110100010010101011101100010010110000011001010000000001001100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 00 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 1010001000110010001011001100001110100010010101011101100010010110000011001010000000001001100000000111
Следующий набор бит: 101000 привел декодера к узлу с символом 'U' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'U':
                         (2)      
                (1)         (1[t])
       (0)         (1[g])         
(0[\0])   (1[U])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                         (3)      
                (2)         (1[t])
       (1)         (1[g])         
(0[\0])   (1[U])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[g])
(0[\0])   (1[U])         

и

(1[t])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (3)                         
(1[t])                   (2)      
                (1)         (1[g])
         (0[\0])   (1[U])         

Текущий результат декодирования сообщения: 'tgU'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
      (3)                         
(1[t])                   (2)      
                (1)         (1[g])
         (0[\0])   (1[U])         

Оставшееся нераскодированное сообщение: 1000110010001011001100001110100010010101011101100010010110000011001010000000001001100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0110010001011001100001110100010010101011101100010010110000011001010000000001001100000000111
Следующий набор бит: 011001 привел декодера к узлу с символом 'F' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'F':
      (3)                                  
(1[t])                            (2)      
                         (1)         (1[g])
                (0)         (1[U])         
         (0[\0])   (1[F])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
      (4)                                  
(1[t])                            (3)      
                         (2)         (1[g])
                (1)         (1[U])         
         (0[\0])   (1[F])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[U])
(0[\0])   (1[F])         

и

(1[t])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                         (4)               
                (2)               (2)      
       (1)         (1[U])   (1[t])   (1[g])
(0[\0])   (1[F])                           

Текущий результат декодирования сообщения: 'tgUF'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                         (4)               
                (2)               (2)      
       (1)         (1[U])   (1[t])   (1[g])
(0[\0])   (1[F])                           

Оставшееся нераскодированное сообщение: 0001011001100001110100010010101011101100010010110000011001010000000001001100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 000 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 1011001100001110100010010101011101100010010110000011001010000000001001100000000111
Следующий набор бит: 101100 привел декодера к узлу с символом 'Y' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'Y':
                                  (4)               
                         (2)               (2)      
                (1)         (1[U])   (1[t])   (1[g])
       (0)         (1[F])                           
(0[\0])   (1[Y])                                    

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                  (5)               
                         (3)               (2)      
                (2)         (1[U])   (1[t])   (1[g])
       (1)         (1[F])                           
(0[\0])   (1[Y])                                    

Требуется перевесить ветки:
                (2)      
       (1)         (1[F])
(0[\0])   (1[Y])         

и

(1[g])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
               (5)                                  
      (2)               (3)                         
(1[g])   (1[U])   (1[t])                   (2)      
                                  (1)         (1[F])
                           (0[\0])   (1[Y])         

Текущий результат декодирования сообщения: 'tgUFY'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
               (5)                                  
      (2)               (3)                         
(1[g])   (1[U])   (1[t])                   (2)      
                                  (1)         (1[F])
                           (0[\0])   (1[Y])         

Оставшееся нераскодированное сообщение: 1100001110100010010101011101100010010110000011001010000000001001100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 1100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 001110100010010101011101100010010110000011001010000000001001100000000111
Следующий набор бит: 001110 привел декодера к узлу с символом 'u' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'u':
               (5)                                           
      (2)               (3)                                  
(1[g])   (1[U])   (1[t])                            (2)      
                                           (1)         (1[F])
                                  (0)         (1[Y])         
                           (0[\0])   (1[u])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
               (6)                                           
      (2)               (4)                                  
(1[g])   (1[U])   (1[t])                            (3)      
                                           (2)         (1[F])
                                  (1)         (1[Y])         
                           (0[\0])   (1[u])                  

Требуется перевесить ветки:
                (2)      
       (1)         (1[Y])
(0[\0])   (1[u])         

и

(1[t])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
               (6)                                           
      (2)                                  (4)               
(1[g])   (1[U])                   (2)               (2)      
                         (1)         (1[Y])   (1[t])   (1[F])
                  (0[\0])   (1[u])                           

Текущий результат декодирования сообщения: 'tgUFYu'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
               (6)                                           
      (2)                                  (4)               
(1[g])   (1[U])                   (2)               (2)      
                         (1)         (1[Y])   (1[t])   (1[F])
                  (0[\0])   (1[u])                           

Оставшееся нераскодированное сообщение: 100010010101011101100010010110000011001010000000001001100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 1000 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 10010101011101100010010110000011001010000000001001100000000111
Следующий набор бит: 100101 привел декодера к узлу с символом 'R' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'R':
               (6)                                                    
      (2)                                           (4)               
(1[g])   (1[U])                            (2)               (2)      
                                  (1)         (1[Y])   (1[t])   (1[F])
                         (0)         (1[u])                           
                  (0[\0])   (1[R])                                    

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
               (7)                                                    
      (2)                                           (5)               
(1[g])   (1[U])                            (3)               (2)      
                                  (2)         (1[Y])   (1[t])   (1[F])
                         (1)         (1[u])                           
                  (0[\0])   (1[R])                                    

Требуется перевесить ветки:
                (2)      
       (1)         (1[u])
(0[\0])   (1[R])         

и

(1[U])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                  (7)                                 
      (3)                                           (4)               
(1[g])                   (2)               (2)               (2)      
                (1)         (1[u])   (1[U])   (1[Y])   (1[t])   (1[F])
         (0[\0])   (1[R])                                             

Текущий результат декодирования сообщения: 'tgUFYuR'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                                  (7)                                 
      (3)                                           (4)               
(1[g])                   (2)               (2)               (2)      
                (1)         (1[u])   (1[U])   (1[Y])   (1[t])   (1[F])
         (0[\0])   (1[R])                                             

Оставшееся нераскодированное сообщение: 01011101100010010110000011001010000000001001100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 0101 привел декодера к узлу с символом 'R', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                                  (7)                                 
      (3)                                           (4)               
(1[g])                   (2)               (2)               (2)      
                (1)         (1[u])   (1[U])   (1[Y])   (1[t])   (1[F])
         (0[\0])   (2[R])                                             

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                                  (8)                                 
      (4)                                           (4)               
(1[g])                   (3)               (2)               (2)      
                (2)         (1[u])   (1[U])   (1[Y])   (1[t])   (1[F])
         (0[\0])   (2[R])                                             

Требуется перевесить ветки:
       (2)      
(0[\0])   (2[R])

и

(1[g])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                  (8)                                 
                (4)                                 (4)               
       (2)               (2)               (2)               (2)      
(0[\0])   (2[R])   (1[g])   (1[u])   (1[U])   (1[Y])   (1[t])   (1[F])

Требуется перевесить ветки:
(2[R])

и

(1[F])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                  (8)                                 
                (3)                                 (5)               
       (1)               (2)               (2)               (3)      
(0[\0])   (1[F])   (1[g])   (1[u])   (1[U])   (1[Y])   (1[t])   (2[R])

Требуется перевесить ветки:
(2[R])

и

       (1)      
(0[\0])   (1[F])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (8)                                           
      (4)                                 (4)                         
(2[R])         (2)               (2)               (2)                
         (1[g])   (1[u])   (1[U])   (1[Y])   (1[t])          (1)      
                                                      (0[\0])   (1[F])

Текущий результат декодирования сообщения: 'tgUFYuRR'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (8)                                           
      (4)                                 (4)                         
(2[R])         (2)               (2)               (2)                
         (1[g])   (1[u])   (1[U])   (1[Y])   (1[t])          (1)      
                                                      (0[\0])   (1[F])

Оставшееся нераскодированное сообщение: 1101100010010110000011001010000000001001100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 110 привел декодера к узлу с символом 't', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                        (8)                                           
      (4)                                 (4)                         
(2[R])         (2)               (2)               (2)                
         (1[g])   (1[u])   (1[U])   (1[Y])   (2[t])          (1)      
                                                      (0[\0])   (1[F])

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (9)                                           
      (4)                                 (5)                         
(2[R])         (2)               (2)               (3)                
         (1[g])   (1[u])   (1[U])   (1[Y])   (2[t])          (1)      
                                                      (0[\0])   (1[F])

Требуется перевесить ветки:
(2[t])

и

       (1)      
(0[\0])   (1[F])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (9)                                           
      (4)                                 (5)                         
(2[R])         (2)               (2)                         (3)      
         (1[g])   (1[u])   (1[U])   (1[Y])          (1)         (2[t])
                                             (0[\0])   (1[F])         

Текущий результат декодирования сообщения: 'tgUFYuRRt'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (9)                                           
      (4)                                 (5)                         
(2[R])         (2)               (2)                         (3)      
         (1[g])   (1[u])   (1[U])   (1[Y])          (1)         (2[t])
                                             (0[\0])   (1[F])         

Оставшееся нераскодированное сообщение: 1100010010110000011001010000000001001100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 1100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 010010110000011001010000000001001100000000111
Следующий набор бит: 010010 привел декодера к узлу с символом 'y' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'y':
                        (9)                                                    
      (4)                                 (5)                                  
(2[R])         (2)               (2)                                  (3)      
         (1[g])   (1[u])   (1[U])   (1[Y])                   (1)         (2[t])
                                                    (0)         (1[F])         
                                             (0[\0])   (1[y])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (10)                                                    
      (4)                                  (6)                                  
(2[R])         (2)                (2)                                  (4)      
         (1[g])   (1[u])    (1[U])   (1[Y])                   (2)         (2[t])
                                                     (1)         (1[F])         
                                              (0[\0])   (1[y])                  

Текущий результат декодирования сообщения: 'tgUFYuRRty'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (10)                                                    
      (4)                                  (6)                                  
(2[R])         (2)                (2)                                  (4)      
         (1[g])   (1[u])    (1[U])   (1[Y])                   (2)         (2[t])
                                                     (1)         (1[F])         
                                              (0[\0])   (1[y])                  

Оставшееся нераскодированное сообщение: 110000011001010000000001001100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 11000 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0011001010000000001001100000000111
Следующий набор бит: 001100 привел декодера к узлу с символом 's' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 's':
                        (10)                                                             
      (4)                                  (6)                                           
(2[R])         (2)                (2)                                           (4)      
         (1[g])   (1[u])    (1[U])   (1[Y])                            (2)         (2[t])
                                                              (1)         (1[F])         
                                                     (0)         (1[y])                  
                                              (0[\0])   (1[s])                           

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (11)                                                             
      (4)                                  (7)                                           
(2[R])         (2)                (2)                                           (5)      
         (1[g])   (1[u])    (1[U])   (1[Y])                            (3)         (2[t])
                                                              (2)         (1[F])         
                                                     (1)         (1[y])                  
                                              (0[\0])   (1[s])                           

Требуется перевесить ветки:
                (2)      
       (1)         (1[y])
(0[\0])   (1[s])         

и

(1[Y])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (11)                                                             
      (4)                                                     (7)                        
(2[R])         (2)                (3)                                           (4)      
         (1[g])   (1[u])    (1[U])                   (2)               (2)         (2[t])
                                            (1)         (1[y])   (1[Y])   (1[F])         
                                     (0[\0])   (1[s])                                    

Текущий результат декодирования сообщения: 'tgUFYuRRtys'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (11)                                                             
      (4)                                                     (7)                        
(2[R])         (2)                (3)                                           (4)      
         (1[g])   (1[u])    (1[U])                   (2)               (2)         (2[t])
                                            (1)         (1[y])   (1[Y])   (1[F])         
                                     (0[\0])   (1[s])                                    

Оставшееся нераскодированное сообщение: 1010000000001001100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 10100 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 00000001001100000000111
Следующий набор бит: 0000000 привел декодера к узлу с символом 'a' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'a':
                        (11)                                                                      
      (4)                                                              (7)                        
(2[R])         (2)                (3)                                                    (4)      
         (1[g])   (1[u])    (1[U])                            (2)               (2)         (2[t])
                                                     (1)         (1[y])   (1[Y])   (1[F])         
                                            (0)         (1[s])                                    
                                     (0[\0])   (1[a])                                             

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (12)                                                                      
      (4)                                                              (8)                        
(2[R])         (2)                (4)                                                    (4)      
         (1[g])   (1[u])    (1[U])                            (3)               (2)         (2[t])
                                                     (2)         (1[y])   (1[Y])   (1[F])         
                                            (1)         (1[s])                                    
                                     (0[\0])   (1[a])                                             

Требуется перевесить ветки:
                (2)      
       (1)         (1[s])
(0[\0])   (1[a])         

и

(1[U])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (12)                                                                      
      (4)                                                              (8)                        
(2[R])         (2)                                   (4)                                 (4)      
         (1[g])   (1[u])                    (2)               (2)               (2)         (2[t])
                                   (1)         (1[s])   (1[U])   (1[y])   (1[Y])   (1[F])         
                            (0[\0])   (1[a])                                                      

Текущий результат декодирования сообщения: 'tgUFYuRRtysa'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (12)                                                                      
      (4)                                                              (8)                        
(2[R])         (2)                                   (4)                                 (4)      
         (1[g])   (1[u])                    (2)               (2)               (2)         (2[t])
                                   (1)         (1[s])   (1[U])   (1[y])   (1[Y])   (1[F])         
                            (0[\0])   (1[a])                                                      

Оставшееся нераскодированное сообщение: 1001100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 1001 привел декодера к узлу с символом 's', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                        (12)                                                                      
      (4)                                                              (8)                        
(2[R])         (2)                                   (4)                                 (4)      
         (1[g])   (1[u])                    (2)               (2)               (2)         (2[t])
                                   (1)         (2[s])   (1[U])   (1[y])   (1[Y])   (1[F])         
                            (0[\0])   (1[a])                                                      

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (13)                                                                      
      (4)                                                              (9)                        
(2[R])         (2)                                   (5)                                 (4)      
         (1[g])   (1[u])                    (3)               (2)               (2)         (2[t])
                                   (1)         (2[s])   (1[U])   (1[y])   (1[Y])   (1[F])         
                            (0[\0])   (1[a])                                                      

Требуется перевесить ветки:
(2[s])

и

(1[u])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                        (13)                                                                      
      (5)                                                              (8)                        
(2[R])         (3)                                   (4)                                 (4)      
         (1[g])   (2[s])                    (2)               (2)               (2)         (2[t])
                                   (1)         (1[u])   (1[U])   (1[y])   (1[Y])   (1[F])         
                            (0[\0])   (1[a])                                                      

Текущий результат декодирования сообщения: 'tgUFYuRRtysas'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                        (13)                                                                      
      (5)                                                              (8)                        
(2[R])         (3)                                   (4)                                 (4)      
         (1[g])   (2[s])                    (2)               (2)               (2)         (2[t])
                                   (1)         (1[u])   (1[U])   (1[y])   (1[Y])   (1[F])         
                            (0[\0])   (1[a])                                                      

Оставшееся нераскодированное сообщение: 100000000111

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 10000 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0000111
Следующий набор бит: 0000111 привел декодера к узлу с символом 'h' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'h':
                        (13)                                                                               
      (5)                                                                       (8)                        
(2[R])         (3)                                            (4)                                 (4)      
         (1[g])   (2[s])                             (2)               (2)               (2)         (2[t])
                                            (1)         (1[u])   (1[U])   (1[y])   (1[Y])   (1[F])         
                                   (0)         (1[a])                                                      
                            (0[\0])   (1[h])                                                               

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                        (14)                                                                               
      (5)                                                                       (9)                        
(2[R])         (3)                                            (5)                                 (4)      
         (1[g])   (2[s])                             (3)               (2)               (2)         (2[t])
                                            (2)         (1[u])   (1[U])   (1[y])   (1[Y])   (1[F])         
                                   (1)         (1[a])                                                      
                            (0[\0])   (1[h])                                                               

Требуется перевесить ветки:
                (2)      
       (1)         (1[a])
(0[\0])   (1[h])         

и

(1[g])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
                                           (14)                                                            
      (6)                                                                       (8)                        
(2[R])                            (4)                         (4)                                 (4)      
                         (2)         (2[s])          (2)               (2)               (2)         (2[t])
                (1)         (1[a])             (1[g])   (1[u])   (1[U])   (1[y])   (1[Y])   (1[F])         
         (0[\0])   (1[h])                                                                                  

Текущий результат декодирования сообщения: 'tgUFYuRRtysash'
---------------------------------
Конец работы декодировщика.
