Алфавит и сгенерированные специальные кода каждого символа:
a - 0000000
b - 0000001
c - 0000010
d - 0000011
e - 0000100
f - 0000101
g - 0000110
h - 0000111
i - 0001000
j - 0001001
k - 0001010
l - 0001011
m - 000110
n - 000111
o - 001000
p - 001001
q - 001010
r - 001011
s - 001100
t - 001101
u - 001110
v - 001111
w - 010000
x - 010001
y - 010010
z - 010011
A - 010100
B - 010101
C - 010110
D - 010111
E - 011000
F - 011001
G - 011010
H - 011011
I - 011100
J - 011101
K - 011110
L - 011111
M - 100000
N - 100001
O - 100010
P - 100011
Q - 100100
R - 100101
S - 100110
T - 100111
U - 101000
V - 101001
W - 101010
X - 101011
Y - 101100
Z - 101101
0 - 101110
1 - 101111
2 - 110000
3 - 110001
4 - 110010
5 - 110011
6 - 110100
7 - 110101
8 - 110110
9 - 110111
. - 111000
, - 111001
! - 111010
? - 111011
: - 111100
( - 111101
) - 111110
  - 111111


Промежуточные данные:
Начало работы декодировщика: на вход декодеру подается последовательность бит:
00110000000000100000011101
---------------------------------
Текущее дерево кодировщика:
(0[\0])

Оставшееся нераскодированное сообщение: 00110000000000100000011101

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит:  привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 00110000000000100000011101
Следующий набор бит: 001100 привел декодера к узлу с символом 's' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 's':
       (0)      
       ||       
  ------------  
  ||        ||  
(0[\0])   (1[s])

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
       (1)      
       ||       
  ------------  
  ||        ||  
(0[\0])   (1[s])

Текущий результат декодирования сообщения: 's'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
       (1)      
       ||       
  ------------  
  ||        ||  
(0[\0])   (1[s])

Оставшееся нераскодированное сообщение: 00000000100000011101

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 0 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 0000000100000011101
Следующий набор бит: 0000000 привел декодера к узлу с символом 'a' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'a':
                (1)      
                ||       
       ----------------  
       ||            ||  
       (0)         (1[s])
       ||                
  ------------           
  ||        ||           
(0[\0])   (1[a])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                (2)      
                ||       
       ----------------  
       ||            ||  
       (1)         (1[s])
       ||                
  ------------           
  ||        ||           
(0[\0])   (1[a])         

Текущий результат декодирования сообщения: 'sa'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                (2)      
                ||       
       ----------------  
       ||            ||  
       (1)         (1[s])
       ||                
  ------------           
  ||        ||           
(0[\0])   (1[a])         

Оставшееся нераскодированное сообщение: 100000011101

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 1 привел декодера к узлу с символом 's', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                (2)      
                ||       
       ----------------  
       ||            ||  
       (1)         (2[s])
       ||                
  ------------           
  ||        ||           
(0[\0])   (1[a])         

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                (3)      
                ||       
       ----------------  
       ||            ||  
       (1)         (2[s])
       ||                
  ------------           
  ||        ||           
(0[\0])   (1[a])         

Текущий результат декодирования сообщения: 'sas'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                (3)      
                ||       
       ----------------  
       ||            ||  
       (1)         (2[s])
       ||                
  ------------           
  ||        ||           
(0[\0])   (1[a])         

Оставшееся нераскодированное сообщение: 00000011101

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 00 привел декодера к узлу с символом '\0' - пустым символом =>
=> по следующим битам нераскодированной части сообщения определяется символ из специальной кодировки

Оставшееся нераскодированное сообщение: 000011101
Следующий набор бит: 0000111 привел декодера к узлу с символом 'h' в дереве специальной кодировки, который и будет очередным результатом декодирования

К узлу с пустым символом добавляются два новых узла:
Левый сын - новый пустой узел, а правый - узел с новым добавленным символом: 'h':
                         (3)      
                         ||       
                ----------------  
                ||            ||  
                (1)         (2[s])
                ||                
       ----------------           
       ||            ||           
       (0)         (1[a])         
       ||                         
  ------------                    
  ||        ||                    
(0[\0])   (1[h])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                         (4)      
                         ||       
                ----------------  
                ||            ||  
                (2)         (2[s])
                ||                
       ----------------           
       ||            ||           
       (1)         (1[a])         
       ||                         
  ------------                    
  ||        ||                    
(0[\0])   (1[h])                  

Текущий результат декодирования сообщения: 'sash'
---------------------------------
---------------------------------
Текущее дерево кодировщика:
                         (4)      
                         ||       
                ----------------  
                ||            ||  
                (2)         (2[s])
                ||                
       ----------------           
       ||            ||           
       (1)         (1[a])         
       ||                         
  ------------                    
  ||        ||                    
(0[\0])   (1[h])                  

Оставшееся нераскодированное сообщение: 01

По первым битам нераскодированной части сообщения строится путь в дереве Хаффмана до тех пор, пока не встретится лист
Следующий набор бит: 01 привел декодера к узлу с символом 'a', который и будет очередным результатом декодирования
Вес узла с этим символом в дереве учеличивается на 1:
                         (4)      
                         ||       
                ----------------  
                ||            ||  
                (2)         (2[s])
                ||                
       ----------------           
       ||            ||           
       (1)         (2[a])         
       ||                         
  ------------                    
  ||        ||                    
(0[\0])   (1[h])                  

Производится пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с пересчитанными весами:
                         (5)      
                         ||       
                ----------------  
                ||            ||  
                (3)         (2[s])
                ||                
       ----------------           
       ||            ||           
       (1)         (2[a])         
       ||                         
  ------------                    
  ||        ||                    
(0[\0])   (1[h])                  

Требуется перевесить ветки:
                (3)      
                ||       
       ----------------  
       ||            ||  
       (1)         (2[a])
       ||                
  ------------           
  ||        ||           
(0[\0])   (1[h])         

и

(2[s])

Повторный пересчет всех весов и перевешивание дерева в случае необходимости:
Дерево с перевешанными ветками и с пересчитанными весами:
      (5)                         
      ||                          
  -------------------------       
  ||                     ||       
(2[s])                   (3)      
                         ||       
                ----------------  
                ||            ||  
                (1)         (2[a])
                ||                
           ------------           
           ||        ||           
         (0[\0])   (1[h])         

Текущий результат декодирования сообщения: 'sasha'
---------------------------------
Конец работы декодировщика.

Результат декодирования:
sasha